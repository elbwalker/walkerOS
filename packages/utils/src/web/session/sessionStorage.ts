import {
  getId,
  getMarketingParameters,
  storageRead,
  storageWrite,
  tryCatch,
} from '../../';
import sessionStart from './sessionStart';
import type { SessionStorageConfig, SessionStorageData } from '.';

export default function sessionStorage(
  config: SessionStorageConfig = {},
  utils: {
    getId: typeof getId;
    getMarketingParameters: typeof getMarketingParameters;
    storageRead: typeof storageRead;
    storageWrite: typeof storageWrite;
    tryCatch: typeof tryCatch;
  },
): SessionStorageData {
  const now = Date.now();
  const length = config.length || 30; // Default session length in minutes

  // Check for an existing session
  const existingSession: Partial<SessionStorageData> | undefined =
    utils.tryCatch((key: string) => {
      const existingSession = JSON.parse(String(utils.storageRead(key)));

      // By default it's not a new session anymore
      existingSession.firstVisit = false;

      // Check if session is still active
      if (existingSession.updated + length * 60 * 1000 < now) {
        // Session has expired
        delete existingSession.id; // Unset session ID
        delete existingSession.referrer; // Unset referrer
        existingSession.start = now; // Set new session start
        existingSession.isNew = true; // Mark expired session a as new one
        existingSession.count++; // Increase session count
      } else {
        // Session is still active
        existingSession.isNew = false;
        existingSession.runs++;
      }

      existingSession.updated = now; // Update session timestamp

      return existingSession;
    })('session');

  // Default session data
  let session: SessionStorageData = {
    id: '', // Will be generated by sessionStart
    start: now,
    updated: now,
    isNew: true,
    firstVisit: true,
    count: 1,
    runs: 1,
  };

  // Use existing session data if available
  config.data = existingSession;

  // Eventually update session with id, referrer and marketing parameters
  session = Object.assign(session, sessionStart(config, utils));

  // @TODO Write (updated) session to storage

  return session;
}
