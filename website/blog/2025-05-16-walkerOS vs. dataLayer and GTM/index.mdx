---
slug: walkerOS-vs-dataLayer-and-GTM
title: 'walkerOS vs. dataLayer + GTM'
description:
  A comparison between tracking with walkerOS and tracking with dataLayer and
  Google Tag Manager.
authors: ayla
tags:
  - Comparison
---

In the world of web analytics and tag management, Google's `dataLayer` has long
been the go-to solution for pushing data to tools like
[Google Tag Manager](https://marketingplatform.google.com/about/tag-manager/).
The `dataLayer` is not a tracking tool by itself. Its a global array that acts
as a messaging bus for Google Tag Manager (GTM).

In this post we will compare the traditional approcach to
[walker.js](https://github.com/elbwalker/walkerOS/tree/main/packages/sources/walkerjs/src),
a modern JavaScript-based event source, that combines necessary and helpful
features for today's web. Built as part of
[walkerOS](https://github.com/elbwalker/walkerOS), walker.js rethinks how
tracking should work in a modern, scalable, and developer-friendly way.

{/* truncate */}

walkerOS is both a tracking orchestrator and an event source. It captures,
structures, queues, and routes events ‚Äî including to GTM.

Let's break down how walkerOS stacks up against the traditional way to track and
why it might be time to reconsider your strategy.

## Event queue and race condition handling

### dataLayer + GTM

The dataLayer was introduced alongside Google Tag Manager in **2012**.

At that time:

- Most websites were multi-page apps (MPAs)
- Page reloads were the norm
- Tag firing was primarily **based on pageviews**

JavaScript-heavy frontends and component-based frameworks like React, Vue, or
Svelte didn't dominate. So the dataLayer design was: A simple way to push events
when pages loaded or user actions occurred.

It worked well for that era.

#### The problems begin in SPAs & Dynamic Apps

##### 1. It's a Fire-and-Forget System

`window.dataLayer.push({ event: 'something' })` is **stateless and ephemeral**.
Once pushed, its immediately processed by GTM if a listener is ready. If the GTM
listener isn't initialized yet (e.g., vendor hasn't loaded), that event is lost.
There's no native queuing, buffering, or replay.

_üîä Think of it like shouting an announcement before the audience enters the
room ‚Äî they'll never hear it._

##### 2. You Need Manual Workarounds

To make dataLayer work reliably in SPAs or dynamic environments, developers
must:

- Re-push virtual pageviews manually on route changes
- Delay or wrap pushes to avoid timing issues
- Build custom buffering logic for late-loaded vendors or consent
- Use additional trigger configurations like trigger groups or custom events

For sure these things aren't impossible ‚Äî but they **require non-trivial effort
and discipline** to maintain at scale.

### walker.js

walker.js uses a **structured event queue** that **immediately** captures and
holds events until the system is ready to process them. It was built for SPA's
by design. It Automatically uses MutationObservers and event listeners to
capture events immediately ‚Äî even before tools or components are fully loaded.
Replays events when tools load Tracks context, consent, and state alongside each
event

It **automates what you must manually wire up** when using dataLayer for
tracking SPAs.

**‚úÖ Advantage: No lost data, even if tools load late. Less hacky work for
developers to handle race conditions.**

## Consent handling

### dataLayer + GTM

GTM can support consent ‚Äî but only through manual setup and coordination. To
handle consent correctly using `dataLayer` and GTM, developers typically must:

Block or delay tag execution until consent is confirmed Configure trigger groups
or write custom logic per tag Hope events aren't missed or sent too early

It's doable ‚Äî but fragile. One small timing issue, and a tag might fire before
the user consented.

_üîä It's like shouting an announcement to the audience before checking whether
they signed a non-disclosure agreement._

### walker.js

walker.js handles consent natively. If you're conditionally loading analytics
tools (like only loading Meta Pixel if a user consents to marketing tools),
walker.js queues and delays sending until all requirements are met ‚Äî but still
capture events right when they happen. So an event is captured instantly. But
only when the [destination](https://www.elbwalker.com/docs/destinations/) (can
also be the dataLayer) is ready, and an eventually required consent state is
explicitly granted, the event gets updated to the latest state and is processed
in the correct order.

This in-built
[consent](https://www.elbwalker.com/docs/sources/walkerjs/commands#consent)
feature helps to comply with legal requirements.

**‚úÖ Advantage: No accidentally shared data to vendors without the users'
consent.**

## Tagging

### dataLayer

Tagging via `dataLayer` is usually hard-coded in your product, and handled in
Google Tag Manager . This leads to a disconnect between your actual website
content and the logic that tracks it. It also leads to missing tracking when new
features are shipped or broken tracking because the `dataLayer.push` is based on
potentially legacy code.

### walker.js

With walker.js, tagging can be **integrated directly into your HTML** using
`data-elb` attributes. This means your tracking setup is closer to your actual
DOM, making it easier to manage, understand, and version-control as part of your
website codebase. It's a long-proven approach just like using CSS with classes.
It's not entirely new, it's a working method.

walker.js therefore is perfectly made to use with **composable components**. It
creates a **current snapshot** of the site and state. A component only has to be
tagged once and can be tracked multiple times, in various settings, on multiple
pages.

E.g. you can add a
[global attribute](https://www.elbwalker.com/docs/sources/walkerjs/tagging#globals)
once and automatically have it available in every event. walker.js also captures
[additional fields](https://www.elbwalker.com/docs/sources/walkerjs/) like event
timings, consent-state, event count or the tagging version automatically. The
states of the events are always up-to-date as a user views certain components on
the screen. Using the dataLayer you'll have to update every single event on its
own.

While it certainly is an effort to add new attributes to each (relevant)
component to start off with, walker.js decreases maintaining, debugging & QA
efforts heavily on the long run. And practically adds tracking to new features
on the fly.

**‚úÖ Advantage: Tagging lives where your content lives ‚Äì in your components'
HTML.**

## Control over vendor logic - UI vs code

### GTM

While you can technically push any data into dataLayer, it was specifically
designed for use within Google Tag Manager. So GTM (UI) becomes your middleman
to send data to external vendors, like Meta‚Äî and that's where things get
fragile.

#### üõ† Example: Sending a ViewContent event to Meta Pixel

Let's say a user views a product. You want Meta Pixel to receive this via the
[`ViewContent` standard event](https://developers.facebook.com/docs/meta-pixel/reference).
Now you must:

- Go into the GTM web UI
- Create a **custom trigger** for the view_content event
- Add the Meta Pixel **tag template**
- Manually map `product_id` and `product_name` from the dataLayer into the
  correct Meta fields like `content_ids` and `content_name` using **variables**
- Make sure the tag is configured to fire under the **right conditions** (e.g.
  after consent)
- Debug and QA everything in **Preview Mode**
- Hope GTM and Meta Pixel both load in time to catch the event but not before
  consent

‚ö†Ô∏è Your tracking logic ‚Äî including **vendor mapping, event logic, consent
handling, firing rules** ‚Äî is **spread across the GTM UI**, with limited
versioning, visibility, and no developer control.

### walkerOS

walkerOS keeps all tracking logic **in your codebase**, not in a 3rd-party UI.
This makes it:

- Easier to version, test, and debug
- Fully integrated with CI/CD and source control
- Predictable, portable, and developer-friendly

HIER DAS LIVE MAPPING BEISPIEL AUS DEN DOCS REIN (von links nach rechts
ViewContent event)

All in code. All in your repo. All under your control.

#### Summary table

| Feature                       | GTM                          | walkerOS                |
| ----------------------------- | ---------------------------- | ----------------------- |
| Logic ‚Üí vendor mapping        | Spread across GTM UI         | In one place, your code |
| Controlled via source code    | ‚ùå No                        | ‚úÖ Yes                  |
| Versioned in Git              | ‚ùå No                        | ‚úÖ Yes                  |
| Sending correct vendor format | ‚ö†Ô∏è Manually mapping via UI   | ‚úÖ Auto via config      |
| Consent-safe execution        | ‚ö†Ô∏è Manually add rules via UI | ‚úÖ Built-in             |
| Adding new vendor             | Build new GTM setup          | Config-only change      |

**‚úÖ Advantage: Tracking logic lives in YOUR code ‚Äî easy to document, test,
reuse, and change.**

## Conclusion: time for an upgrade?

**The dataLayer and GTM were designed for websites in 2012.**

They where not built for:

- SPAs and dynamic content
- Consent-dependent tracking
- Modern developer workflows with components, CI/CD, and versioning

**walkerOS is.**
