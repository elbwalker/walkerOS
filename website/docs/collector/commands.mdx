---
title: Commands
description: Collector API methods and commands
path: /docs/collector/commands
sidebar_position: 3
package: '@walkeros/collector'
---

# Collector Commands

The collector provides a core event processing engine that manages destinations,
consent, user data, and custom properties. Commands are executed through the
`elb` function

:::note

For browser-specific commands like DOM initialization and elbLayer
communication, see <Link to="/docs/sources/web/browser/commands">Browser Source
Commands</Link>.

:::

## destination

Add destinations to the collector for event processing. Destinations handle the
actual delivery of events to third-party services.

<CodeSnippet
  code={`// Add destination dynamically at runtime
const destinationLog = { push: console.log };
elb('walker destination', destinationLog);

// Real destination example
import { destinationGtag } from '@walkeros/web-destination-gtag';
elb('walker destination', destinationGtag, {
/* custom config */
});
`}
  language="javascript"
/>

:::tip

Destinations are typically configured during collector initialization:

<CodeSnippet
  code={`const { collector, elb } = await startFlow({
destinations: {
gtag: {
code: destinationGtag,
config: {
  /* custom config */
},
},
},
});
`}
  language="typescript"
/>

See destination-specific documentation for configuration options.

:::

## consent

Manage consent states for the collector. Names can be defined arbitrarily, but
common groups are functional, analytics, and marketing. Values are booleans, and
once a value is set to `true` it's treated as consent being granted.

<CodeSnippet
  code={`elb('walker consent', { marketing: true, analytics: true });
`}
  language="javascript"
/>

Setting a consent state to `false` will immediately stop a destination from
processing any events. Previously pushed events during the run are shared with
existing destinations once consent is granted.

:::info

Learn more about <Link to="/docs/guides/consent/">consent management</Link>
in detail.

:::

## on

Add event listeners to the collector. They get called when specific events occur
like `run` or `consent` changes.

<CodeSnippet
  code={`elb('walker on', type, options);
`}
  language="javascript"
/>

`Options` depend on `type` and can also be an array for multiple listeners at
once.

### run

With each `run`, the on-event will be called with `instance` as a parameter.

<CodeSnippet
  code={`elb('walker on', 'run', function (instance) {
console.log('run with', { instance });
});
`}
  language="javascript"
/>

Every time the `run` command is called, the function will be executed:

<CodeSnippet
  code={`// Setup collector with browser source
const { collector } = await startFlow({ run: true });
// Output: run with { instance: { ... } }
elb('walker run');
// Output: run with { instance: { ... } }
`}
  language="javascript"
/>

### consent

Every time the `consent` changes, the rules-matching function(s) will be called
with the parameters `instance` and `consent`.

<CodeSnippet
  code={`function onConsent(instance, consent) {
console.log('consent with', { instance, consent });
if (consent.marketing) elb('walker user', readFromStorage());
}

//   command      type        rule       function
elb('walker on', 'consent', { marketing: onConsent });
`}
  language="javascript"
/>

The `onConsent` function will only be called when the `marketing` consent
changes:

<CodeSnippet
  code={`elb('walker consent', { functional: true }); // Won't trigger the onConsent function
elb('walker consent', { marketing: true }); // Will trigger the onConsent function
`}
  language="javascript"
/>

## user

Set user identification data for the collector. There are three levels: user
(company's internal ID), device (longer-term identifier), and session (temporary
identification).

<CodeSnippet
  code={`elb('walker user', { id: 'us3r', device: 'c00k13', session: 's3ss10n' });
`}
  language="javascript"
/>

User IDs are added to each event.

<CodeSnippet
  code={`{
"event": "entity action",
"user": {
"id": "us3r",
"device": "c00k13",
"session": "s3ss10n"
}
// other properties omitted
}
`}
  language="javascript"
/>

:::warning

Use fully anonymized & arbitrary IDs by default and check your options with
persistent user IDs with your data protection officer.

:::

:::tip

Learn more about identification
and <Link to="/docs/guides/user-stitching">user stitching</Link>

:::

## custom

Set custom properties that are added to each event processed by the collector.

<CodeSnippet
  code={`elb('walker custom', { key: 'value' });
`}
  language="javascript"
/>

## globals

Set global properties that are added to each event processed by the collector.

<CodeSnippet
  code={`elb('walker globals', { key: 'value' });
`}
  language="javascript"
/>

## hook

Hooks customize the default behavior of the collector. Available hooks include
`Push`, `DestinationInit`, and `DestinationPush`. Hooks allow for validation,
manipulation, or cancellation of default behavior.

Add hooks to the collector to customize or enhance default processing.

<CodeSnippet
  code={`elb('walker hook', '<moment>', hookFn);
`}
  language="javascript"
/>

### Moments

The overall function execution order is as follows:

1. prePush
2. preDestinationInit
3. postDestinationInit
4. preDestinationPush or preDestinationPushBatch
5. postDestinationPush or postDestinationPushBatch
6. postPush

Others are:

* preSessionStart
* postSessionStart

### Function signatures

In general, `params` will be prefixed as a parameter, containing `fn` which is
the original function and `result` for the post-hooks. Use the following
function signatures:

<CodeSnippet
  code={`// Push
function prePush(params, event, data, options, context, nested) {
return params.fn(event, data, options, context, nested);
}
function postPush(params, event, data, trigger, context, nested) {
console.log('default return result', params.result);
return;
}

// DestinationInit
function preDestinationInit(params, config) {
return params.fn(config);
}
function postDestinationInit(params, config) {
console.log('default return result', params.result);
return params.result;
}

// DestinationPush
function preDestinationPush(params, event, config, mapping, runState) {
console.log('default return result', params.result);
return params.fn(event, config, mapping, runState);
}
function postDestinationPush(params) {
// Custom code with a void return
return;
}

// DestinationPushBatch
function preDestinationPushBatch(params, event, config, mapping, runState) {
console.log('default return result', params.result);
return params.fn(event, config, mapping, runState);
}
function postDestinationPushBatch(params) {
// Custom code with a void return
return;
}
`}
  language="javascript"
/>

### Adding a hook

Add hooks during collector initialization or via the `hook` command:

<CodeSnippet
  code={`// Add hooks during initialization
const { collector } = await startFlow({
hooks: {
prePush: (params, ...args) => {
window.elbTimer = Date.now();
return params.fn(...args);
},
},
});

// Add hooks via command
elb('walker hook', 'postPush', function (params, ...args) {
console.log('walker exec time', Date.now() - window.elbTimer);
});

elb('entity action');

// Output:
// walker exec time 1
`}
  language="javascript"
/>
