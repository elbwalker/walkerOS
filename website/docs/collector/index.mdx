---
title: Collector
description: Unified event collector for web and server environments
path: /docs/collector
package: '@walkeros/collector'
sidebar_position: 2
---

import { schemas } from '@walkeros/core/dev';

export const collectorSchema = schemas.CollectorSchemas.initConfigJsonSchema;

# Collector

The collector is the central **processing engine** of walkerOS that receives
events from sources, **enriches** them with additional data, applies consent
rules, and **routes** them to destinations. It acts as the **intelligent
middleware** between event capture and event delivery.

#### What it does

The Collector transforms raw events into enriched, compliant data streams by:

* **Event processing** - Validates, normalizes, and enriches incoming events
* **Consent management** - Applies privacy rules and user consent preferences
* **Data enrichment** - Adds session data, user context, and custom properties
* **Destination routing** - Sends processed events to configured analytics
  platforms

#### Key features

* **Compatibility** - Works in both web browsers and server environments
* **Privacy-first** - Built-in consent management and data protection
* **Event validation** - Ensures data quality and consistency
* **Flexible routing** - Send events to multiple destinations simultaneously
* **Delivery status** - Built-in per-source and per-destination delivery tracking

#### Role in architecture

In the walkerOS data flow, the collector sits between sources and destinations:

<FlowMap
  sources={{ default: { highlight: false } }}
  collector={{ highlight: true }}
  destinations={{ default: { highlight: false } }}
  markers={[
    { position: 'source-collector', id: '1', text: 'Receive: Incoming mapped events from sources' },
    { position: 'collector', id: '2', text: 'Process: State management, consent handling, enrichment' },
    { position: 'collector-destination', id: '3', text: 'Route: Map events to destination-specific requirements' },
  ]}
/>

Sources capture events and send them to the collector, which processes and
routes them to your chosen destinations like Google Analytics, custom APIs, or
data warehouses.

## Installation

<CodeSnippet
  code={`npm install @walkeros/collector`}
  language="bash"
/>

## Basic setup

<CodeSnippet
  code={`import { startFlow } from '@walkeros/collector';
import { sourceBrowser } from '@walkeros/web-source-browser';

const { collector, elb } = await startFlow({
consent: { functional: true },
sources: {
browser: {
  code: sourceBrowser,
  config: {
    settings: {
      pageview: true,
      session: true,
    },
  },
},
},
destinations: {
console: {
  code: true, // Built-in code destination
  config: {
    settings: {
      push: "console.log('Event:', event)",
    },
  },
},
},
});`}
  language="typescript"
/>

## Configuration reference

<PropertyTable schema={collectorSchema} />

## Advanced setup

<CodeSnippet
  code={`import { startFlow } from '@walkeros/collector';
import { sourceBrowser } from '@walkeros/web-source-browser';
import { destinationAPI } from '@walkeros/web-destination-api';

const { collector, elb } = await startFlow({
consent: { functional: true },
sources: {
browser: {
  code: sourceBrowser,
  config: {
    settings: {
      pageview: true,
      session: true,
    },
  },
},
},
destinations: {
api: {
  code: destinationAPI,
  config: {
    settings: {
      url: 'https://analytics.example.com/events',
    },
  },
},
},
logger: {
level: 'DEBUG', // Show all logs (ERROR, INFO, DEBUG)
},
});`}
  language="typescript"
/>

## Event transformation

The collector works with **mapping** to transform events as they flow through the system. Mapping is configured at the destination level and controls how walkerOS events are converted to vendor-specific formats.

<FlowMap
  sources={{ default: { label: 'walkerOS', text: 'Event' } }}
  collector={{ label: 'Dest', text: 'Mapping' }}
  destinations={{ default: { label: 'Vendor', text: 'Format' } }}
/>

For example, transforming a `product add` event into GA4's `add_to_cart`:

<CodeSnippet
  code={`destinations: {
  ga4: {
    code: destinationGtag,
    config: {
      mapping: {
        product: {
          add: {
            name: 'add_to_cart',
            data: {
              map: {
                currency: { value: 'USD' },
                value: 'data.price',
                items: { loop: ['nested', { map: { item_id: 'data.id' } }] }
              }
            }
          }
        }
      }
    }
  }
}`}
  language="typescript"
/>

[**Learn more about mapping â†’**](/docs/mapping)

## Status

The collector tracks delivery metrics on `collector.status`, giving you real-time
visibility into event flow without external monitoring:

<CodeSnippet
  code={`const { collector } = await startFlow({ /* ... */ });

// After events have been processed
console.log(collector.status);
// {
//   startedAt: 1707580800000,
//   in: 100,       // Total events received
//   out: 95,       // Total events delivered
//   failed: 5,     // Total failures
//   sources: {
//     browser: { count: 100, lastAt: 1707580900000, duration: 1200 }
//   },
//   destinations: {
//     ga4: { count: 95, failed: 0, lastAt: 1707580900000, duration: 800 },
//     meta: { count: 0, failed: 5, lastAt: 1707580850000, duration: 400 }
//   }
// }

// Compute average destination push time
const ga4 = collector.status.destinations.ga4;
const avgMs = ga4.duration / (ga4.count + ga4.failed);`}
  language="typescript"
/>

Queue sizes and DLQ sizes can be read directly from destination instances:

<CodeSnippet
  code={`const dest = collector.destinations['meta'];
const queueSize = dest.queuePush?.length || 0;
const dlqSize = dest.dlq?.length || 0;`}
  language="typescript"
/>

---

## See also

- [**Operating modes**](/docs/getting-started/modes): integrated vs bundled approaches
- [**CLI documentation**](/docs/apps/cli): configure with JSON and build with CLI
- [**Sources**](/docs/sources): available event capture sources
- [**Destinations**](/docs/destinations): available event delivery destinations
