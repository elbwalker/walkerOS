---
title: dataLayer + GTM vs. walkerOS
sidebar_position: 2
description:
  A comparison between tracking with walkerOS and tracking with dataLayer and
  Google Tag Manager.
---

import Link from '@docusaurus/Link';
import { getEvent } from '@elbwalker/utils';
import {
  DestinationContextProvider,
  DestinationInit,
  DestinationPush,
} from '@site/src/components/organisms/liveDestination';
import destinationMetaPixel from '@elbwalker/destination-web-meta-pixel';
import { mapping } from '@elbwalker/destination-web-meta-pixel/examples';

---

<DestinationContextProvider destination={destinationMetaPixel} fnName="fbq" >

In the world of web analytics and tag management, Google's `dataLayer` has long
been the go-to solution for pushing data to tools like
[Google Tag Manager](https://marketingplatform.google.com/about/tag-manager/).
The `dataLayer` is not a tracking tool by itself. Its a global array that acts
as a messaging bus for Google Tag Manager (GTM).

In this post we will compare `dataLayer` + GTM to
[walker.js](https://github.com/elbwalker/walkerOS/tree/main/packages/sources/walkerjs/src),
a modern JavaScript-based event source, that combines necessary and helpful
features for tracking today's web. Built as part of
[walkerOS](https://github.com/elbwalker/walkerOS), it rethinks how tracking
should work in a modern, scalable, and developer-friendly way. walkerOS is both
a tracking orchestrator and an event source. It captures, structures, queues,
and routes events.

{/* truncate */}

Depending on the feature we will compare both tools as event sources
(`dataLayer` vs. walker.js), and/or orchestrators (GTM vs. walkerOS).

## State management and race condition handling

### dataLayer + GTM

The dataLayer was introduced alongside Google Tag Manager in **2012**.

At that time:

- Most websites were multi-page apps (MPAs)
- Page reloads were the norm
- Tag firing was primarily **based on pageviews**
- JavaScript-heavy front-ends and component-based frameworks like React, Vue, or
  Svelte didn't dominate (or even existed).

So the dataLayer design was: A simple way to push events when pages loaded or
user actions occurred.

It worked well for that era.

The problems begin in SPAs & Dynamic Apps. To make the `dataLayer` work reliably
in SPAs or dynamic environments, developers (depending on the setup) typically
must:

- Ensure pushes occur after asynchronous content loads or after consent is given
- Delay or wrap pushes to avoid timing issues
- Build custom buffering logic or re-loop the `dataLayer` for late-loaded
  vendors or consent updates
- Optionally use additional trigger configurations in GTM such like trigger
  groups or custom events to manage firing conditions

For sure these things aren't impossible ‚Äî but they **require non-trivial effort
and discipline** to maintain at scale.

### walker.js

walker.js uses a structured event queue designed for modern websites and
dynamically loaded content.

It offers pre-built
[triggers](https://www.elbwalker.com/docs/sources/walkerjs/tagging#triggers)
that automatically use MutationObservers and event listeners to capture events
immediately ‚Äî even before tools or components are fully loaded. It was designed
to automatically buffer and manage events and state.

It **automates what you must manually wire up** when using `dataLayer`.

**‚úÖ Advantage: Both technologies can handle race conditions and manage event
states. walker.js comes with in-built features to reduce hacky manual work for
developers.**

## Consent handling

### dataLayer + GTM

GTM supports consent ‚Äî but only through manual setup and coordination. To handle
consent correctly using `dataLayer` and GTM, developers typically must:

1. Block or delay tag execution until consent is confirmed
2. Configure trigger groups or write custom logic per tag
3. Read storage (e.g. user id from cookies) and update events
4. Hope events aren't missed or sent too early

It's doable ‚Äî but fragile. One small config issue, and a tag might fire before
the user consented, leading to PII leakage.

### walker.js

walker.js **handles consent natively**. If you're conditionally loading
analytics tools (like only loading Meta Pixel if a user consents to marketing
tools), walker.js queues and delays sending until all requirements are met ‚Äî but
still capture events right when they happen. So an event is captured instantly.
But only when the [destination](https://www.elbwalker.com/docs/destinations/)
(can also be the dataLayer) is ready, and an eventually required consent state
is explicitly granted, the event gets updated to the latest state and is
processed in the correct order.

This in-built
[consent](https://www.elbwalker.com/docs/sources/walkerjs/commands#consent)
feature helps to ensure users privacy and to comply with legal requirements.

**‚úÖ Advantage: Both tools can handle consent. walker.js has in-built features
to reduce manual work and no data is accidentally shared to vendors without the
users' consent.**

## Tagging

### dataLayer

Tagging via `dataLayer` is often deeply hard-coded into the product or entirely
managed through Google Tag Manager. This approach creates a disconnect between
the website's actual content and the tracking logic. As a result, new features
are frequently launched without proper tracking in place. Because tracking is
decoupled from the core functionality, it's often treated as an afterthought
rather than an integral part of the development and release process.

### walker.js

With walker.js, tagging can be **integrated directly into your HTML** using
`data-elb` attributes. This means your tracking setup is closer to your actual
DOM, making it easier to manage, understand, and version-control as part of your
website codebase. It's a long-proven approach just like using CSS with classes.
It's not entirely new, it's an established method.

walker.js therefore is perfectly made to use with **composable components**. It
creates a **current snapshot** of the site and state, and builds events on the
fly. A component only has to be tagged once and can be tracked multiple times,
in various settings, on multiple pages.

E.g. you can add a
[global attribute](https://www.elbwalker.com/docs/sources/walkerjs/tagging#globals)
once and automatically have it available in every event. walker.js also captures
[additional fields](https://www.elbwalker.com/docs/sources/walkerjs/) like event
timings, consent-state, event count or the tagging version automatically. The
states of the events are always up-to-date as a user interacts with certain
components on the screen. Using the dataLayer you'll have to update every single
event on its own.

While it certainly is an effort to add new attributes to each (relevant)
component to start off with, walker.js decreases maintaining, debugging & QA
efforts heavily on the long run. And practically adds tracking to new features
on the fly.

**‚úÖ Advantage: Tagging is integrated into your components, easy to add, ready
to scale.**

## Control over vendor logic - UI vs code

### GTM

Historically, GTM quickly became the go-to middleman for sending data also to
non-Google tools ‚Äî and that's where things started to get messy.

**üõ† Example: Simplified workflow for sending a ViewContent event to Meta
Pixel**

Let's say a user views a product. You want Meta Pixel to receive this via the
[`ViewContent` standard event](https://developers.facebook.com/docs/meta-pixel/reference).
Now you must:

- Go into the GTM web UI and create a **custom trigger** for the `view_content`
  event
- Add the Meta Pixel **tag template**
- Manually map `product_id` and `product_name` from the dataLayer into the
  correct Meta fields like `content_ids` and `content_name` using **variables**.
- Make sure the tag is configured to fire under the **right conditions** (e.g.
  after consent)
- Debug and QA everything

It's a tedious, click-heavy process filled with constant screen-hopping and
endless overlays, turning even simple tasks into a fragmented, time-consuming
hassle.

‚ö†Ô∏è Your whole tracking logic ‚Äî including **vendor mapping, event logic, consent
handling, firing rules** ‚Äî is **spread across the GTM UI**, with limited
versioning, visibility, and no developer control.

### walkerOS

walkerOS keeps all tracking logic **in your codebase**, not in a 3rd-party UI.
This makes it:

- Easier to version, test, and debug
- Fully integrated with CI/CD and source control
- Predictable, portable, and developer-friendly

You can map an event to Meta Pixel's format using a simple config file (in-built
for each destination) ‚Äî walkerOS then automatically generates the correct
`fbq('track', ...)` call:

<DestinationPush
  smallText={true}
  height={'512px'}
  event={getEvent('product view')}
  mapping={mapping.ViewContent}
/>

All in code. All in your repo. All under your control. Predictable.

**‚úÖ Advantage: Tracking logic lives in **your** code ‚Äî easy to document, test,
reuse, and change.**

## Summary table

| Feature                    | `dataLayer` + GTM      | walkerOS                             |
| -------------------------- | ---------------------- | ------------------------------------ |
| Tagging integration        | Manual pushes          | Component-level, DOM attribute based |
| Event state management     | Manual updates         | Automatic, real-time state updating  |
| Consent-safe execution     | Yes, with manual setup | Built-in                             |
| Logic ‚Üí vendor mapping     | Spread across GTM UI   | In your code                         |
| Controlled via source code | ‚ùå No                  | ‚úÖ Yes                               |
| Versioned in Git           | ‚ùå No                  | ‚úÖ Yes                               |

## Conclusion: time for an upgrade?

**The `dataLayer` and GTM were designed for websites and development workflows
in 2012.**

They where not built for:

- Dynamically loaded content
- Consent-dependent tracking
- Modern developer workflows with components, CI/CD, and versioning

... **walkerOS is.**

walkerOS is also a great alternative for teams that don't want to use GTM in
their frontend due to privacy concerns and compliance rules.

## Integration options for existing setups

In case you are not fully ready to switch or not starting from scratch we offer
ways to integrate with GTM:

- **Use walker.js tagging with GTM UI:**

If you'd like to use walker.js
[tagging](https://www.elbwalker.com/docs/sources/walkerjs/tagging) while keeping
GTM UI for other tasks, you can use the
[Google Tag Manager destination](https://www.elbwalker.com/docs/destinations/google-gtm)
that automatically pushes walker events into the `dataLayer`

- **Combine your existing `dataLayer` with code-based tag management:**

If you already have a mature `dataLayer` setup but want to replace the GTM UI
for managing tags, use the
[dataLayer source](https://www.elbwalker.com//docs/sources/dataLayer/) along
with our [destinations](https://www.elbwalker.com//docs/destinations/) to
transform and route events to your vendors.

</DestinationContextProvider>

:::info

Need help with walkerOS? Check out our&nbsp;<Link to="/services">services</Link>
to get support straight from the creators.

:::
