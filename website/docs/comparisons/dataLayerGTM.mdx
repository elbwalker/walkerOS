---
title: dataLayer + GTM vs. walkerOS
sidebar_position: 2
description:
  A comparison between tracking with walkerOS and tracking with dataLayer and
  Google Tag Manager.
---

import Link from '@docusaurus/Link';
import { getEvent } from '@elbwalker/utils';
import {
  DestinationContextProvider,
  DestinationInit,
  DestinationPush,
} from '@site/src/components/organisms/liveDestination';
import destinationMetaPixel from '@elbwalker/destination-web-meta-pixel';
import { mapping } from '@elbwalker/destination-web-meta-pixel/examples';

---

<DestinationContextProvider destination={destinationMetaPixel} fnName="fbq" >

In the world of web analytics and tag management, Google's `dataLayer` has long
been the go-to solution for pushing data to tools like
[Google Tag Manager](https://marketingplatform.google.com/about/tag-manager/).
The `dataLayer` is not a tracking tool by itself. Its a global array that acts
as a messaging bus for Google Tag Manager (GTM).

In this post we will compare the traditional approach (`dataLayer` + GTM) to
[walker.js](https://github.com/elbwalker/walkerOS/tree/main/packages/sources/walkerjs/src),
a modern JavaScript-based event source, that combines necessary and helpful
features for today's web. Built as part of
[walkerOS](https://github.com/elbwalker/walkerOS), it rethinks how tracking
should work in a modern, scalable, and developer-friendly way. walkerOS is both
a tracking orchestrator and an event source. It captures, structures, queues,
and routes events.

{/* truncate */}

Depending on the feature we will compare both tools as event sources
(`dataLayer` vs. walker.js) , and orchestrators (GTM vs. walkerOS).

## State management and race condition handling

### dataLayer + GTM

The dataLayer was introduced alongside Google Tag Manager in **2012**.

At that time:

- Most websites were multi-page apps (MPAs)
- Page reloads were the norm
- Tag firing was primarily **based on pageviews**
- JavaScript-heavy front-ends and component-based frameworks like React, Vue, or
  Svelte didn't dominate (or even existed).

So the dataLayer design was: A simple way to push events when pages loaded or
user actions occurred.

It worked well for that era.

The problems begin in SPAs & Dynamic Apps. To make the `dataLayer` work reliably
in SPAs or dynamic environments, developers (depending on the setup) typically
must:

- Ensure pushes occur after asynchronous content loads or after consent is given
- Delay or wrap pushes to avoid timing issues
- Build custom buffering logic or re-loop the `dataLayer` for late-loaded
  vendors or consent updates
- Optionally use additional trigger configurations in GTM such like trigger
  groups or custom events to manage firing conditions

For sure these things aren't impossible ‚Äî but they **require non-trivial effort
and discipline** to maintain at scale.

### walker.js

walker.js uses a structured event queue designed for modern websites and
dynamically loaded content.

It offers pre-built
[triggers](https://www.elbwalker.com/docs/sources/walkerjs/tagging#triggers)
that automatically use MutationObservers and event listeners to capture events
immediately ‚Äî even before tools or components are fully loaded. It was designed
to automatically buffer and manage events and state.

It **automates what you must manually wire up** when using `dataLayer`.

#### Summary table

| Feature                         | GTM                             | walkerOS                |
| ------------------------------- | ------------------------------- | ----------------------- |
| Dynamic content event capturing | Manual pushes, timing-sensitive | Automatic, and buffered |

**‚úÖ Advantage: Reduce hacky work for developers to handle state and race
conditions.**

## Consent handling

### dataLayer + GTM

GTM can support consent ‚Äî but only through manual setup and coordination. To
handle consent correctly using `dataLayer` and GTM, developers typically must:

1. Block or delay tag execution until consent is confirmed
2. Configure trigger groups or write custom logic per tag
3. Read storage (e.g. user id from cookies) and update events
4. Hope events aren't missed or sent too early

It's doable ‚Äî but fragile. One small timing issue, and a tag might fire before
the user consented, leading to PII leakage.

### walker.js

walker.js **handles consent natively**. If you're conditionally loading
analytics tools (like only loading Meta Pixel if a user consents to marketing
tools), walker.js queues and delays sending until all requirements are met ‚Äî but
still capture events right when they happen. So an event is captured instantly.
But only when the [destination](https://www.elbwalker.com/docs/destinations/)
(can also be the dataLayer) is ready, and an eventually required consent state
is explicitly granted, the event gets updated to the latest state and is
processed in the correct order.

This in-built
[consent](https://www.elbwalker.com/docs/sources/walkerjs/commands#consent)
feature helps to ensure users privacy and to comply with legal requirements.

#### Summary table

| Feature          | GTM                          | walkerOS                                     |
| ---------------- | ---------------------------- | -------------------------------------------- |
| Consent handling | Manual setup, fragile timing | Built-in consent state tracking and updating |

**‚úÖ Advantage: No accidentally shared data to vendors without the users'
consent. Guaranteed peace of mind.**

## Tagging

### dataLayer

Tagging via `dataLayer` is usually hard-coded deeply in your product, and/or
fully handled in Google Tag Manager. This leads to a disconnect between your
actual website content and the logic that tracks it. It also leads to missing
tracking when new features are shipped or broken tracking because the
`dataLayer.push` is based on potentially legacy code.

### walker.js

With walker.js, tagging can be **integrated directly into your HTML** using
`data-elb` attributes. This means your tracking setup is closer to your actual
DOM, making it easier to manage, understand, and version-control as part of your
website codebase. It's a long-proven approach just like using CSS with classes.
It's not entirely new, it's an established method.

walker.js therefore is perfectly made to use with **composable components**. It
creates a **current snapshot** of the site and state. A component only has to be
tagged once and can be tracked multiple times, in various settings, on multiple
pages.

E.g. you can add a
[global attribute](https://www.elbwalker.com/docs/sources/walkerjs/tagging#globals)
once and automatically have it available in every event. walker.js also captures
[additional fields](https://www.elbwalker.com/docs/sources/walkerjs/) like event
timings, consent-state, event count or the tagging version automatically. The
states of the events are always up-to-date as a user views certain components on
the screen. Using the dataLayer you'll have to update every single event on its
own.

While it certainly is an effort to add new attributes to each (relevant)
component to start off with, walker.js decreases maintaining, debugging & QA
efforts heavily on the long run. And practically adds tracking to new features
on the fly.

#### Summary table

| Feature             | GTM                      | walkerOS                             |
| ------------------- | ------------------------ | ------------------------------------ |
| Tagging integration | Scattered, manual pushes | Component-level, DOM attribute based |

**‚úÖ Advantage: Tagging is integrated into your components, easy to add, ready
to scale.**

## Control over vendor logic - UI vs code

### GTM

Historically, GTM quickly became the go-to middleman for sending data also to
non-Google tools ‚Äî and that's where things started to get messy.

**üõ† Example: Simplified workflow for sending a ViewContent event to Meta
Pixel**

Let's say a user views a product. You want Meta Pixel to receive this via the
[`ViewContent` standard event](https://developers.facebook.com/docs/meta-pixel/reference).
Now you must:

- Go into the GTM web UI and create a **custom trigger** for the `view_content`
  event
- Add the Meta Pixel **tag template**
- Manually map `product_id` and `product_name` from the dataLayer into the
  correct Meta fields like `content_ids` and `content_name` using **variables**.
- Make sure the tag is configured to fire under the **right conditions** (e.g.
  after consent)
- Debug and QA everything

It's a tedious, click-heavy process filled with constant screen-hopping and
endless overlays, turning even simple tasks into a fragmented, time-consuming
hassle.

‚ö†Ô∏è Your whole tracking logic ‚Äî including **vendor mapping, event logic, consent
handling, firing rules** ‚Äî is **spread across the GTM UI**, with limited
versioning, visibility, and no developer control.

### walkerOS

walkerOS keeps all tracking logic **in your codebase**, not in a 3rd-party UI.
This makes it:

- Easier to version, test, and debug
- Fully integrated with CI/CD and source control
- Predictable, portable, and developer-friendly

You can map an event to Meta Pixel's format using a simple config file (in-built
for each destination) ‚Äî walkerOS then automatically generates the correct
`fbq('track', ...)` call:

<DestinationPush
  smallText={true}
  height={'512px'}
  event={getEvent('product view')}
  mapping={mapping.ViewContent}
/>

All in code. All in your repo. All under your control. Predictable.

#### Summary table

| Feature                       | GTM                          | walkerOS                |
| ----------------------------- | ---------------------------- | ----------------------- |
| Logic ‚Üí vendor mapping        | Spread across GTM UI         | In one place, your code |
| Controlled via source code    | ‚ùå No                        | ‚úÖ Yes                  |
| Versioned in Git              | ‚ùå No                        | ‚úÖ Yes                  |
| Sending correct vendor format | ‚ö†Ô∏è Manually mapping via UI   | ‚úÖ Auto via config      |
| Consent-safe execution        | ‚ö†Ô∏è Manually add rules via UI | ‚úÖ Built-in             |
| Adding new vendor             | Build new GTM setup          | Config-only change      |

**‚úÖ Advantage: Tracking logic lives in **your** code ‚Äî easy to document, test,
reuse, and change.**

## Conclusion: time for an upgrade?

**The `dataLayer` and GTM were designed for websites in 2012.**

They where not built for:

- Dynamically loaded content
- Consent-dependent tracking
- Modern developer workflows with components, CI/CD, and versioning

... **walkerOS is.**

## Integration options for existing setups

In case you are not fully ready to switch or not starting from scratch we offer
several ways to integrate with GTM:

- **Install walkerOS via GTM:** If you don't have access to the website's source
  code you can use our official walkerOS
  [Tag Template](https://www.elbwalker.com/docs/sources/walkerjs/installation/gtm/).
  The setup is handled through Custom JavaScript variables for both
  initialization and configuration of
  [destinations](https://www.elbwalker.com//docs/destinations/).
- **Use walker.js tagging with GTM UI:** If you'd like to use walker.js
  [tagging](https://www.elbwalker.com/docs/sources/walkerjs/tagging) while
  keeping GTM UI for other tasks, you can use the
  [Google Tag Manager destination](https://www.elbwalker.com/docs/destinations/google-gtm)
  to push walker events into the `dataLayer`
- **Combine your existing `dataLayer` with code-based tagging:** If you already
  have a mature `dataLayer` setup but prefer managing tags as code, use the
  [dataLayer source](https://www.elbwalker.com//docs/sources/dataLayer/) along
  with our [destinations](https://www.elbwalker.com//docs/destinations/) to
  transform and route events to your vendors.

</DestinationContextProvider>

:::info

If you need professional support with your walkerOS implementation, check out
our&nbsp;<Link to="/services">services</Link>.

:::
