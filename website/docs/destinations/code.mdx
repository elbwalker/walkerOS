---
title: Code
description: Built-in destination for executing custom code strings
sidebar_position: 0
---

# Code Destination

The code destination is a built-in, platform-agnostic destination that executes
custom JavaScript code strings. It provides a lightweight alternative to tag
managers like GTM, allowing you to run arbitrary code in response to events
without external dependencies.

## Setup

Use `code: true` to enable the built-in code destination:

<CodeSnippet
  code={`import { startFlow } from '@walkeros/collector';

const { collector, elb } = await startFlow({
  destinations: {
    analytics: {
      code: true,
      config: {
        settings: {
          init: "context.logger.info('Analytics ready')",
          push: "context.logger.debug('Event:', event.name)",
        },
      },
    },
  },
});`}
  language="typescript"
/>

## Configuration Reference

### Settings

| Property    | Type     | Description                                      |
| ----------- | -------- | ------------------------------------------------ |
| `init`      | `string` | Code to run once when the destination initializes |
| `on`        | `string` | Code to run on lifecycle events (consent, etc.)  |
| `push`      | `string` | Default code to run for each event               |
| `pushBatch` | `string` | Default code to run for batched events           |

### Mapping

Event-specific code can override settings via mapping:

| Property    | Type     | Description                           |
| ----------- | -------- | ------------------------------------- |
| `push`      | `string` | Code to run for this specific event   |
| `pushBatch` | `string` | Code to run for batched events        |

## Context Variables

Each code string has access to specific variables:

### init

- `context.collector` - The collector instance
- `context.config` - Destination configuration
- `context.env` - Environment variables
- `context.logger` - Scoped logger instance

### push

- `event` - The WalkerOS event object
- `context.collector` - The collector instance
- `context.config` - Destination configuration
- `context.data` - Transformed event data (from mapping)
- `context.env` - Environment variables
- `context.logger` - Scoped logger instance
- `context.mapping` - The event mapping rule

### pushBatch

- `batch.key` - The batch key (event name)
- `batch.events` - Array of events in the batch
- `batch.data` - Array of transformed data
- `context.collector` - The collector instance
- `context.config` - Destination configuration
- `context.env` - Environment variables
- `context.logger` - Scoped logger instance
- `context.mapping` - The event mapping rule

### on

- `type` - The event type (`'consent'`, `'ready'`, etc.)
- `context.collector` - The collector instance
- `context.config` - Destination configuration
- `context.data` - Event-specific data
- `context.env` - Environment variables
- `context.logger` - Scoped logger instance

## Examples

### Basic Logging

<CodeSnippet
  code={`const { elb } = await startFlow({
  destinations: {
    logger: {
      code: true,
      config: {
        settings: {
          push: "console.log('Event:', event.name, event.data)",
        },
      },
    },
  },
});`}
  language="typescript"
/>

### API Calls

<CodeSnippet
  code={`const { elb } = await startFlow({
  destinations: {
    api: {
      code: true,
      config: {
        settings: {
          push: \`
            fetch('https://api.example.com/track', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                name: event.name,
                data: event.data,
                timestamp: event.timestamp
              })
            })
          \`,
        },
      },
    },
  },
});`}
  language="typescript"
/>

### Consent Handling

<CodeSnippet
  code={`const { elb } = await startFlow({
  destinations: {
    tracking: {
      code: true,
      config: {
        settings: {
          on: \`
            if (type === 'consent' && context.data?.marketing) {
              context.logger.info('Marketing consent granted');
              // Initialize third-party scripts
            }
          \`,
          push: "context.logger.debug(event.name)",
        },
      },
    },
  },
});`}
  language="typescript"
/>

### Event-Specific Overrides

Use mapping to override the default push code for specific events:

<CodeSnippet
  code={`const { elb } = await startFlow({
  destinations: {
    analytics: {
      code: true,
      config: {
        settings: {
          // Default handler for all events
          push: "context.logger.debug('Event:', event.name)",
        },
        mapping: {
          product: {
            view: {
              // Custom handler for product view events
              push: \`
                fetch('/api/product-view', {
                  method: 'POST',
                  body: JSON.stringify({
                    productId: event.data.id,
                    name: event.data.name
                  })
                })
              \`,
            },
          },
          order: {
            complete: {
              // Custom handler for purchase events
              push: \`
                window.dataLayer?.push({
                  event: 'purchase',
                  value: event.data.total,
                  transaction_id: event.data.id
                })
              \`,
            },
          },
        },
      },
    },
  },
});`}
  language="typescript"
/>

### Batched Events

<CodeSnippet
  code={`const { elb } = await startFlow({
  destinations: {
    batchApi: {
      code: true,
      config: {
        settings: {
          pushBatch: \`
            fetch('/api/batch', {
              method: 'POST',
              body: JSON.stringify({
                events: batch.events.map(e => ({
                  name: e.name,
                  data: e.data
                }))
              })
            })
          \`,
        },
        mapping: {
          '*': {
            '*': {
              batch: 1000, // Batch events with 1 second debounce
            },
          },
        },
      },
    },
  },
});`}
  language="typescript"
/>

## Error Handling

All code execution is wrapped in try-catch blocks. Errors are logged using the
destination's scoped logger and don't affect other destinations or event
processing.

<CodeSnippet
  code={`// Errors are caught and logged automatically
settings: {
  push: \`
    // This error will be logged but won't crash the app
    throw new Error('Something went wrong');
  \`,
}`}
  language="typescript"
/>

## Security Considerations

The code destination uses `new Function()` to execute code strings. This is
similar to `eval()` and should only be used with trusted code. Never execute
user-provided code strings directly.

For production environments, consider:

- Only using code strings defined in your source code
- Validating and sanitizing any dynamic configuration
- Using Content Security Policy headers where appropriate
