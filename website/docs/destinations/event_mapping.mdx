---
title: Event Mapping
description: How to transform events into another required format.
sidebar_position: 3
---

import { DestinationContextProvider } from '@site/src/components/templates/destination';
import { DestinationPush } from '@site/src/components/templates/destination';
import Link from '@docusaurus/Link';
import { getEvent } from '@elbwalker/utils';

export const event = getEvent('order complete');

<DestinationContextProvider
  destination={{
    push: (event, config, mapping, options) => {
      return config.fn(options.data);
    },
    pushBatch: (batched, config, options) => {
      return config.fn(batched);
    }
  }}
>

Mapping is used to configure and translate walkerOS events for destinations. It
defines if and how to process events, by renaming, structuring, bundling, or
ignoring them. It's also checking for consent and validate values.

## Config

Besides a general destination configuration, a mapping config is set for a
specific event. Therefore it is defined as
`{ [entity]: { [action]: EventConfig }}`.

A `*` can be used to match all entities or actions and set up common rules. Each
destination requires specific settings which can be configured in the `custom`
section of the mapping.

```ts
{
  // Config
  [entity]: {
    [action]: {
      // EventConfig
      name: "event name",
      data: {
        // ValueConfig
      }
    }
  }
}
```

<DestinationPush event={event} height={'666px'} labelMiddle={'Config'} eventConfig={false} smallText={true}>
  {`{
    order: {
      complete: {
        name: "purchase",
        data: {
          map: {
            event: "event",
            id: 'data.id',
            pageGroup: 'globals.pagegroup',
            quantity: { fn: (e) => e.nested.length },
            products: {
            loop: ['nested', 'data.name']
            },
            user_id: {
              consent: { marketing: true },
              key: "user.id",
              value: "anonymous",
            },
            vip: {
              condition: (e) => e.data.total > 500,
              value: true,
            },
            journeyShopping: {
              key: 'context.shopping.0',
              validate: (value) => typeof value == "string",
            },
            timings: {
              set: ['timestamp', 'timing']
            }
          }
        }
      },
      visible: { batch: 1000, data: "event" },
      '*' : { ignore: true }
    }
  }`}
</DestinationPush>

## EventConfig

The `Destination.Event` mapping for each event supports standardized default
options. The `custom` option can be used to set up custom properties for the
event and destination's individual settings.

| Property      | Value    | Description                                                              |
| ------------- | -------- | ------------------------------------------------------------------------ |
| **name**      | string   | Renaming of the event (e.g. `product add` to `add_to_cart`)              |
| **data**      | object   | How to transform the event data.                                         |
| **ignore**    | boolean  | If set to `true` the event won't get pushed to the destination.          |
| **condition** | function | A function to check if the mapping should be used.                       |
| **consent**   | object   | Required states to process the event.                                    |
| **custom**    | object   | Individual settings for a custom destination.                            |
| **batch**     | number   | Time in ms to bundle the events before calling `pushBatch` if available. |

To disable processing of other events, add `{'*': {'*': { ignore: true }}}` to
the mapping.

The destination event mapping technically uses
the&nbsp;<Link to="/docs/utils/mapping">mapping utils</Link> to create the
desired event structure. And
the&nbsp;<Link to="/docs/utils/helper#getbypath">getByPath</Link> dot notation
to access event properties (e.g. `event.data.total`).

### name

The `name` property is used to rename the event. It overrides the original event
name.

<DestinationPush event={{ event: event.event }}>
  {`{
    name: "purchase",
    data: "event"
  }`}
</DestinationPush>

Example: A walkerOS `order complete` usually becomes a `purchase` event in GA4
or an `order` event in Piwik PRO.

### data

### ignore

The `ignore` property is used to ignore the event.

### consent

The `consent` property is used to require a specific state to process the event.

### custom

The `custom` property is used to set up custom properties for the event and
destination's individual settings.

### batch

The `batch` property is used to bundle the events before calling `pushBatch` if
available.

## ValueConfig

The `data` property is used to transform the event data. It is used to create
the required data structure for the destination.

It can create any structure of data. With support for recursive data structures.

### key

A key accesses a property from the event context.

<DestinationPush event={{ data: event.data }}>
  {`{
    data: {
      key: 'data.id'
    }
  }`}
</DestinationPush>

### string

A simple string is short for `{key: 'value'}`. And accesses a property from the
event context.

<DestinationPush event={{ data: event.data }}>
  {`{
    data: "data.total"
  }`}
</DestinationPush>

### value

Used for creating a static value. Can also be used as a fallback if no other
mapping resolves a value.

<DestinationPush event={{ data: event.event }}>
  {`{
    data: {
      value: 'static'
    }
  }`}
</DestinationPush>

### map

Used to create an object. The keys are the property names and the values are
again `Mapping.Data` which are `ValueConfig` (@TODO was ist das) resolving to a
`WalkerOS.Property`.

<DestinationPush event={{ globals: event.globals, context: event.context }}>
  {`{
    data: {
      map: {
        pageGroup: 'globals.pagegroup',
        shoppingStage: 'context.shopping.0',
      }
    }
  }`}
</DestinationPush>

### set

Used to create an array of fixed values. Each item is a `ValueConfig` resolving
to a `WalkerOS.Property`.

<DestinationPush
  event={{
    trigger: event.trigger,
    entity: event.entity,
    action: event.action,
  }}
>
  {`{
    data: {
      set: ['trigger', 'entity', 'action']
    }
  }`}
</DestinationPush>

### loop

Loops over the first parameter and maps the second to the current value. It is
used for creating an array of dynamic length.

<DestinationPush event={{ nested: event.nested }} height={'256px'}>
  {`{
    data: {
      loop: ['nested', 'data.name']
    }
  }`}
</DestinationPush>

### condition

Is a function to check if the mapping should be used. It returns a boolean, if
it's `true` the mapping will be used.

<DestinationPush event={{ event: event.event, data: event.data }}>
  {`{
    data: {
      condition: (e) => e.data.total > 100,
      key: "event"
    },
  }`}
</DestinationPush>

### consent

Some values may require an explicit consent state. It can be used to redact
values and protect a users privacy by hiding information.

<DestinationPush event={{ consent: { marketing: true }, data: event.data }}>
  {`{
    data: {
      consent: { marketing: true },
      key: 'data.id',
      value: 'redacted',
    }
  }`}
</DestinationPush>

This can be used to e.g. redact PII like clickIds from a `session start` event.

### fn

A function that returns the value. It receives the current `event` context, the
`mapping` configuration and the `options` about the current instance with
additional properties as parameters.

<DestinationPush event={{ data: event.data }}>
  {`{
    data: {
      fn: (event) => {
        return "id is " + event.data.id;
      }
    }
  }`}
</DestinationPush>

### validate

A final check to validate the value. After `key`, `loop`, `map` or `set`
resolved the value, it will be validated with the `validate` function.

<DestinationPush event={{ data: event.data }}>
  {`{
    data: {
      validate: (value) => typeof value == "string",
      key: "data.id",
      value: "fallback"
    }
  }`}
</DestinationPush>

## Execution order

If the `data` property is an array, the mappings will be executed in the order
until a first value is resolved. Usually, a `condition` is used to check if the
mapping should be used. If permission is denied, the static default `value`
would be returned. Then the `consent` checks if the user granted permission to
process the event or value. First, `value` is used to set the static/default
value. Next, `fn` gets executed. Then a given `key` or `string`. If set, either
`loop`, `map` or `loop`, `map` or `set` is processed. After that, the value gets
checked with the `validate` function. Finally, the value is casted to the
correct type. If the validation or casting fails, the value will be either the
static default `value` or the next mapping would be used or ultimately
`undefined`.

## Example

:::warning

Make sure to not list duplicate keys in the mapping, since this is an object.

:::

:::tip

Use&nbsp;<Link to="/docs/utils/hooks">hooks</Link> to modify events before
processing.

:::

:::info

If you need professional support with your walkerOS implementation, check out
our&nbsp;<Link to="/services">services</Link>.

:::

</DestinationContextProvider>
