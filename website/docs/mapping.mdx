***

title: Mapping
description: Unified event transformation for sources and destinations
sidebar\_position: 4
--------------------

import Link from '@docusaurus/Link';
import { LiveCode, CodeBox } from '@walkeros/explorer';
import { getMappingEvent, getMappingValue } from '@walkeros/core';
import { parseInput } from '@site/src/components/molecules/codeBox';

export const logEvent = async (input, config, log) => {
  log(await parseInput(input, { getMappingEvent }));
};
export const logValue = async (input, config, log) => {
  log(await parseInput(input, { getMappingValue }));
};

# Mapping

Mapping transforms your events - either as they come from sources or before they
go to destinations. Use the same mapping syntax in both places.

## Why Mapping?

**For Sources:** Clean up messy input data, filter unwanted events, normalize
formats

**For Destinations:** Transform events to match what each tool expects (GA4,
Meta, etc.)

## When to Use

**Source Mapping:**

* Filter test/debug events before they reach your collector
* Rename inconsistent event names from different sources
* Validate or normalize data before processing

**Destination Mapping:**

* Transform event names to match destination requirements (e.g., `product view`
  → `view_item` for GA4)
* Reshape data to fit destination APIs
* Add required fields like currency codes

## How It Works

Map events by their entity-action structure:

<CodeBox
  code={`// Source: Clean up what comes in
sources: {
browser: {
  config: {
    mapping: {
      product: {
        click: { name: 'product view' }  // Standardize clicks to views
      },
      test: {
        '*': { ignore: true }  // Filter out test events
      }
    }
  }
}
}

// Destination: Format for specific tools
destinations: {
gtag: {
  config: {
    mapping: {
      product: {
        view: {
          name: 'view_item',  // GA4 expects this name
          data: {
            map: {
              item_id: 'data.id',
              value: 'data.price'
            }
          }
        }
      }
    }
  }
}
}
`}
  disabled
  language="typescript"
  label="Code Example"
  showHeader={false}
  autoHeight={{ min: 100, max: 600 }}
/>

Both mappings are independent - one event can be transformed differently at each
stage.

## What You Can Do

* **Rename events** to match your needs or destination requirements
* **Filter events** by ignoring unwanted ones
* **Reshape data** to match destination formats
* **Add static values** like currency codes
* **Validate data** before sending
* **Require consent** to respect user privacy
* **Apply policies** to modify events at config or event level

## Event Mapping with getMappingEvent

`getMappingEvent(event: WalkerOS.PartialEvent, mapping?: Mapping.Rules): Promise<Mapping.Result>`

This function finds the appropriate mapping configuration for an event based on
its entity and action.

### Basic Event Mapping

Map specific entity-action combinations to custom event names:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
  { name: 'product view' },
  {
    product: {
      view: { name: 'product_viewed' },
    },
  }
);`}
  output={`{
  eventMapping: {
    name: "product_viewed"
  },
  mappingKey: "product view"
}`}
  fn={logEvent}
/>

### Wildcard Mappings

Use wildcards (`*`) to match multiple entities or actions:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
  { name: 'product click' },
  {
    product: {
      '*': { name: 'product_interaction' },
    },
    '*': {
      click: { name: 'generic_click' },
    },
  }
);`}
  output={`{
  eventMapping: {
    name: "product_interaction"
  },
  mappingKey: "product *"
}`}
  fn={logEvent}
/>

### Conditional Mappings

Use conditions to apply different mappings based on event properties:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
  {
    name: 'order complete',
    data: { value: 100 },
  },
  {
    order: {
      complete: [
        {
          condition: (event) => event.data?.value > 50,
          name: 'high_value_purchase',
        },
        { name: 'purchase' }, // Fallback
      ],
    },
  }
);`}
  output={`{
  eventMapping: {
    name: "high_value_purchase"
  },
  mappingKey: "order complete"
}`}
  fn={logEvent}
/>

### Ignoring Events

Skip processing certain events by setting `ignore: true`:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
  { name: 'test event' },
  {
    test: {
      event: { ignore: true },
    },
  }
);`}
  output={`{
  eventMapping: {
    ignore: true
  },
  mappingKey: "test event"
}`}
  fn={logEvent}
/>

## Value Mapping with getMappingValue

`getMappingValue(value: unknown, mapping: Mapping.Data, options?: Mapping.Options): Promise<WalkerOS.Property | undefined>`

This function transforms values using various mapping strategies.

### String Key Mapping

Use a string to extract a value by its property path:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
  { user: { id: '12345', name: 'John' } },
  'user.id'
);`}
  output={`"12345"`}
  fn={logValue}
/>

### Array Access

Access array elements using dot notation:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
  { products: ['laptop', 'mouse', 'keyboard'] },
  'products.0'
);`}
  output={`"laptop"`}
  fn={logValue}
/>

### Static Values

Return static values using the `value` property:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
  { name: 'page view' },
  { value: 'pageview' }
);`}
  output={`"pageview"`}
  fn={logValue}
/>

### Custom Functions

Transform values using custom functions:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
  { user: { email: 'john@example.com' } },
  {
    fn: (event) => event.user.email.split('@')[1]
  }
);`}
  output={`"example.com"`}
  fn={logValue}
/>

### Object Mapping

Create new objects by mapping properties:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
  {
    product: { id: 'P123', name: 'Laptop', price: 999 },
    user: { id: 'U456' }
  },
  {
    map: {
      item_id: 'product.id',
      item_name: 'product.name',
      value: 'product.price',
      user_id: 'user.id',
      currency: { value: 'USD' },
    }
  }
);`}
  output={`{
  item_id: "P123",
  item_name: "Laptop",
  value: 999,
  user_id: "U456",
  currency: "USD"
}`}
  fn={logValue}
/>

### Array Processing with Loop

Process arrays and transform each item:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
  {
    products: [
      { id: 'P1', name: 'Laptop' },
      { id: 'P2', name: 'Mouse' }
    ]
  },
  {
    loop: [
      'products',
      { map: { item_id: 'id', item_name: 'name' } }
    ]
  }
);`}
  output={`[
  { item_id: "P1", item_name: "Laptop" },
  { item_id: "P2", item_name: "Mouse" }
]`}
  fn={logValue}
/>

### Validation

Validate values and return undefined if validation fails:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
  { email: 'john@example.com' },
  {
    key: 'email',
    validate: (value) => typeof value === 'string' && value.includes('@')
  }
);`}
  output={`"john@example.com"`}
  fn={logValue}
/>

### Consent-Based Mapping

Only return values when required consent is granted:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
  {
    email: 'john@example.com',
    consent: { marketing: false, functional: true }
  },
  {
    key: 'email',
    consent: { marketing: true }
  }
);`}
  output={`undefined`}
  fn={logValue}
/>

## Policy

Policies modify events before processing. Apply them at **config-level** (all
events) or **event-level** (specific entity-action combinations).

**Processing order**: Config policy → Event matching → Event policy → Data
transformation

### Config-Level Policy

Global transformations applied to all events:

<CodeBox
  code={`config: {
policy: {
  'user.email': { fn: (e) => e.user?.email?.toLowerCase() },
  'data.timestamp': { fn: () => Date.now() },
},
}`}
  disabled
  language="typescript"
  label="Code Example"
  showHeader={false}
  autoHeight={{ min: 100, max: 600 }}
/>

### Event-Level Policy

Transformations for specific events:

<CodeBox
  code={`config: {
mapping: {
  product: {
    view: {
      name: 'view_item',
      policy: {
        'data.id': { fn: (e) => \`PRODUCT_\${e.data?.id}\` },
      },
    },
  },
},
}`}
  disabled
  language="typescript"
  label="Code Example"
  showHeader={false}
  autoHeight={{ min: 100, max: 600 }}
/>

Policies work with wildcards and conditions, and both levels can be combined -
config policy runs first, then event policy for the matched rule.

## Usage Examples

### Source Mapping

Normalize events before they reach the collector:

<CodeBox
  code={`await startFlow({
sources: {
  browser: {
    code: sourceBrowser,
    config: {
      mapping: {
        // Rename DOM clicks to views
        product: {
          click: {
            name: 'product view',
            policy: {
              // Event-level: normalize product IDs
              'data.id': { fn: (e) => e.data?.id?.toUpperCase() },
            },
          },
        },
        // Ignore test events
        test: { '*': { ignore: true } },
      },
      policy: {
        // Config-level: normalize user email for all events
        'user.email': { fn: (e) => e.user?.email?.toLowerCase() },
      },
    },
  },
},
});`}
  disabled
  language="typescript"
  label="Code Example"
  showHeader={false}
  autoHeight={{ min: 100, max: 600 }}
/>

### Destination Mapping

Transform for specific destination APIs:

<CodeBox
  code={`await startFlow({
destinations: {
  gtag: {
    code: destinationGtag,
    config: {
      mapping: {
        product: {
          view: {
            name: 'view_item',
            data: {
              map: {
                item_id: 'data.id',
                value: 'data.price',
                currency: { value: 'USD' },
              },
            },
          },
        },
      },
    },
  },
},
});`}
  disabled
  language="typescript"
  label="Code Example"
  showHeader={false}
  autoHeight={{ min: 100, max: 600 }}
/>

### Combined Flow

Event processed twice with different configs:

<CodeBox
  code={`// 1. Browser sends: "product click"
// 2. Source mapping: "product click" → "product view"
// 3. Destination mapping: "product view" → "view_item"
// 4. GA4 receives: "view_item"`}
  disabled
  language="typescript"
  label="Code Example"
  showHeader={false}
  autoHeight={{ min: 100, max: 600 }}
/>

## Best Practices

1. **Source mapping**: Normalize, filter, validate incoming events
2. **Destination mapping**: Transform to destination-specific formats
3. **Use specific mappings** over wildcards for better performance
4. **Validate critical data** before sending to destinations
5. **Respect consent** by using consent-based mappings
6. **Keep transformations simple** - complex logic in custom functions
