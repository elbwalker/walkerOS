---
title: Mapping
description: Unified event transformation for sources and destinations
sidebar_position: 4
---

import Link from '@docusaurus/Link';
import { LiveCode } from '@site/src/components/organisms/liveCode';
import { getMappingEvent, getMappingValue } from '@walkeros/core';
import { parseInput } from '@site/src/components/molecules/codeBox';

export const logEvent = async (input, config, log) => {
  log(await parseInput(input, { getMappingEvent }));
};
export const logValue = async (input, config, log) => {
  log(await parseInput(input, { getMappingValue }));
};

# Mapping

Mapping transforms your events - either as they come from sources or before they
go to destinations. Use the same mapping syntax in both places.

## Why Mapping?

**For Sources:** Clean up messy input data, filter unwanted events, normalize
formats

**For Destinations:** Transform events to match what each tool expects (GA4,
Meta, etc.)

## When to Use

**Source Mapping:**

- Filter test/debug events before they reach your collector
- Rename inconsistent event names from different sources
- Validate or normalize data before processing

**Destination Mapping:**

- Transform event names to match destination requirements (e.g., `product view`
  → `view_item` for GA4)
- Reshape data to fit destination APIs
- Add required fields like currency codes

## How It Works

Map events by their entity-action structure:

```typescript
// Source: Clean up what comes in
sources: {
  browser: {
    config: {
      mapping: {
        product: {
          click: { name: 'product view' }  // Standardize clicks to views
        },
        test: {
          '*': { ignore: true }  // Filter out test events
        }
      }
    }
  }
}

// Destination: Format for specific tools
destinations: {
  gtag: {
    config: {
      mapping: {
        product: {
          view: {
            name: 'view_item',  // GA4 expects this name
            data: {
              map: {
                item_id: 'data.id',
                value: 'data.price'
              }
            }
          }
        }
      }
    }
  }
}
```

Both mappings are independent - one event can be transformed differently at each
stage.

## What You Can Do

- **Rename events** to match your needs or destination requirements
- **Filter events** by ignoring unwanted ones
- **Reshape data** to match destination formats
- **Add static values** like currency codes
- **Validate data** before sending
- **Require consent** to respect user privacy
- **Apply policies** to modify events at config or event level

## Event Mapping with getMappingEvent

`getMappingEvent(event: WalkerOS.PartialEvent, mapping?: Mapping.Rules): Promise<Mapping.Result>`

This function finds the appropriate mapping configuration for an event based on
its entity and action.

### Basic Event Mapping

Map specific entity-action combinations to custom event names:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
    { name: 'product view' },
    {
      product: {
        view: { name: 'product_viewed' },
      },
    }
  );`}
  output={`{
    eventMapping: {
      name: "product_viewed"
    },
    mappingKey: "product view"
  }`}
  fn={logEvent}
/>

### Wildcard Mappings

Use wildcards (`*`) to match multiple entities or actions:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
    { name: 'product click' },
    {
      product: {
        '*': { name: 'product_interaction' },
      },
      '*': {
        click: { name: 'generic_click' },
      },
    }
  );`}
  output={`{
    eventMapping: {
      name: "product_interaction"
    },
    mappingKey: "product *"
  }`}
  fn={logEvent}
/>

### Conditional Mappings

Use conditions to apply different mappings based on event properties:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
    {
      name: 'order complete',
      data: { value: 100 },
    },
    {
      order: {
        complete: [
          {
            condition: (event) => event.data?.value > 50,
            name: 'high_value_purchase',
          },
          { name: 'purchase' }, // Fallback
        ],
      },
    }
  );`}
  output={`{
    eventMapping: {
      name: "high_value_purchase"
    },
    mappingKey: "order complete"
  }`}
  fn={logEvent}
/>

### Ignoring Events

Skip processing certain events by setting `ignore: true`:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
    { name: 'test event' },
    {
      test: {
        event: { ignore: true },
      },
    }
  );`}
  output={`{
    eventMapping: {
      ignore: true
    },
    mappingKey: "test event"
  }`}
  fn={logEvent}
/>

## Value Mapping with getMappingValue

`getMappingValue(value: unknown, mapping: Mapping.Data, options?: Mapping.Options): Promise<WalkerOS.Property | undefined>`

This function transforms values using various mapping strategies.

### String Key Mapping

Use a string to extract a value by its property path:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
    { user: { id: '12345', name: 'John' } },
    'user.id'
  );`}
  output={`"12345"`}
  fn={logValue}
/>

### Array Access

Access array elements using dot notation:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
    { products: ['laptop', 'mouse', 'keyboard'] },
    'products.0'
  );`}
  output={`"laptop"`}
  fn={logValue}
/>

### Static Values

Return static values using the `value` property:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
    { name: 'page view' },
    { value: 'pageview' }
  );`}
  output={`"pageview"`}
  fn={logValue}
/>

### Custom Functions

Transform values using custom functions:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
    { user: { email: 'john@example.com' } },
    {
      fn: (event) => event.user.email.split('@')[1]
    }
  );`}
  output={`"example.com"`}
  fn={logValue}
/>

### Object Mapping

Create new objects by mapping properties:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
    {
      product: { id: 'P123', name: 'Laptop', price: 999 },
      user: { id: 'U456' }
    },
    {
      map: {
        item_id: 'product.id',
        item_name: 'product.name',
        value: 'product.price',
        user_id: 'user.id',
        currency: { value: 'USD' },
      }
    }
  );`}
  output={`{
    item_id: "P123",
    item_name: "Laptop",
    value: 999,
    user_id: "U456",
    currency: "USD"
  }`}
  fn={logValue}
/>

### Array Processing with Loop

Process arrays and transform each item:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
    {
      products: [
        { id: 'P1', name: 'Laptop' },
        { id: 'P2', name: 'Mouse' }
      ]
    },
    {
      loop: [
        'products',
        { map: { item_id: 'id', item_name: 'name' } }
      ]
    }
  );`}
  output={`[
    { item_id: "P1", item_name: "Laptop" },
    { item_id: "P2", item_name: "Mouse" }
  ]`}
  fn={logValue}
/>

### Validation

Validate values and return undefined if validation fails:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
    { email: 'john@example.com' },
    {
      key: 'email',
      validate: (value) => typeof value === 'string' && value.includes('@')
    }
  );`}
  output={`"john@example.com"`}
  fn={logValue}
/>

### Consent-Based Mapping

Only return values when required consent is granted:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
    {
      email: 'john@example.com',
      consent: { marketing: false, functional: true }
    },
    {
      key: 'email',
      consent: { marketing: true }
    }
  );`}
  output={`undefined`}
  fn={logValue}
/>

## Policy

Policies modify events before processing. Apply them at **config-level** (all
events) or **event-level** (specific entity-action combinations).

**Processing order**: Config policy → Event matching → Event policy → Data
transformation

### Config-Level Policy

Global transformations applied to all events:

```typescript
config: {
  policy: {
    'user.email': { fn: (e) => e.user?.email?.toLowerCase() },
    'data.timestamp': { fn: () => Date.now() },
  },
}
```

### Event-Level Policy

Transformations for specific events:

```typescript
config: {
  mapping: {
    product: {
      view: {
        name: 'view_item',
        policy: {
          'data.id': { fn: (e) => `PRODUCT_${e.data?.id}` },
        },
      },
    },
  },
}
```

Policies work with wildcards and conditions, and both levels can be combined -
config policy runs first, then event policy for the matched rule.

## Usage Examples

### Source Mapping

Normalize events before they reach the collector:

```typescript
await startFlow({
  sources: {
    browser: {
      code: sourceBrowser,
      config: {
        mapping: {
          // Rename DOM clicks to views
          product: {
            click: {
              name: 'product view',
              policy: {
                // Event-level: normalize product IDs
                'data.id': { fn: (e) => e.data?.id?.toUpperCase() },
              },
            },
          },
          // Ignore test events
          test: { '*': { ignore: true } },
        },
        policy: {
          // Config-level: normalize user email for all events
          'user.email': { fn: (e) => e.user?.email?.toLowerCase() },
        },
      },
    },
  },
});
```

### Destination Mapping

Transform for specific destination APIs:

```typescript
await startFlow({
  destinations: {
    gtag: {
      code: destinationGtag,
      config: {
        mapping: {
          product: {
            view: {
              name: 'view_item',
              data: {
                map: {
                  item_id: 'data.id',
                  value: 'data.price',
                  currency: { value: 'USD' },
                },
              },
            },
          },
        },
      },
    },
  },
});
```

### Combined Flow

Event processed twice with different configs:

```typescript
// 1. Browser sends: "product click"
// 2. Source mapping: "product click" → "product view"
// 3. Destination mapping: "product view" → "view_item"
// 4. GA4 receives: "view_item"
```

## Best Practices

1. **Source mapping**: Normalize, filter, validate incoming events
2. **Destination mapping**: Transform to destination-specific formats
3. **Use specific mappings** over wildcards for better performance
4. **Validate critical data** before sending to destinations
5. **Respect consent** by using consent-based mappings
6. **Keep transformations simple** - complex logic in custom functions
