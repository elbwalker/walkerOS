---
title: Mapping
description: Unified event transformation for sources and destinations
sidebar_position: 4
---

import { getMappingEvent, getMappingValue } from '@walkeros/core';

export const parseInput = (code, scope = {}) => {
  const codeStr = String(code);
  return new Function(
    ...Object.keys(scope),
    `"use strict"; return (async () => { return ${codeStr} })()`,
  )(...Object.values(scope));
};

export const logEvent = async (input, config, log) => {
  log(await parseInput(input, { getMappingEvent }));
};
export const logValue = async (input, config, log) => {
  log(await parseInput(input, { getMappingValue }));
};

# Mapping

Mapping transforms your events - either as they come from sources or before they
go to destinations. Use the same mapping syntax in both places.

## Why mapping?

**For Sources:** Clean up messy input data, filter unwanted events, normalize
formats

**For Destinations:** Transform events to match what each tool expects (GA4,
Meta, etc.)

## When to use

**Source Mapping:**

* Filter test/debug events before they reach your collector
* Rename inconsistent event names from different sources
* Validate or normalize data before processing

**Destination Mapping:**

* Transform event names to match destination requirements (e.g., `product view`
  → `view_item` for GA4)
* Reshape data to fit destination APIs
* Add required fields like currency codes

## How it works

Map events by their entity-action structure:

<CodeSnippet
  code={`// Source: Clean up what comes in
sources: {
browser: {
config: {
mapping: {
  product: {
    click: { name: 'product view' }  // Standardize clicks to views
  },
  test: {
    '*': { ignore: true }  // Filter out test events
  }
}
}
}
}

// Destination: Format for specific tools
destinations: {
gtag: {
config: {
mapping: {
  product: {
    view: {
      name: 'view_item',  // GA4 expects this name
      data: {
        map: {
          item_id: 'data.id',
          value: 'data.price'
        }
      }
    }
  }
}
}
}
}`}
  language="typescript"
/>

Both mappings are independent - one event can be transformed differently at each
stage.

## What you can do

* **Rename events** to match your needs or destination requirements
* **Filter events** by ignoring unwanted ones
* **Reshape data** to match destination formats
* **Add static values** like currency codes
* **Validate data** before sending
* **Require consent** to respect user privacy
* **Apply policies** to modify events at config or event level

## Event mapping with getMappingEvent

`getMappingEvent(event: WalkerOS.PartialEvent, mapping?: Mapping.Rules): Promise<Mapping.Result>`

This function finds the appropriate mapping configuration for an event based on
its entity and action.

### Basic event mapping

Map specific entity-action combinations to custom event names:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
{ name: 'product view' },
{
product: {
  view: { name: 'product_viewed' },
},
}
);`}
  output={`{
eventMapping: {
name: "product_viewed"
},
mappingKey: "product view"
}`}
  fn={logEvent}
/>

### Wildcard mappings

Use wildcards (`*`) to match multiple entities or actions:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
{ name: 'product click' },
{
product: {
  '*': { name: 'product_interaction' },
},
'*': {
  click: { name: 'generic_click' },
},
}
);`}
  output={`{
eventMapping: {
name: "product_interaction"
},
mappingKey: "product *"
}`}
  fn={logEvent}
/>

### Conditional mappings

Use conditions to apply different mappings based on event properties:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
{
name: 'order complete',
data: { value: 100 },
},
{
order: {
  complete: [
    {
      condition: (event) => event.data?.value > 50,
      name: 'high_value_purchase',
    },
    { name: 'purchase' }, // Fallback
  ],
},
}
);`}
  output={`{
eventMapping: {
name: "high_value_purchase"
},
mappingKey: "order complete"
}`}
  fn={logEvent}
/>

### Ignoring events

Skip processing certain events by setting `ignore: true`:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingEvent(
{ name: 'test event' },
{
test: {
  event: { ignore: true },
},
}
);`}
  output={`{
eventMapping: {
ignore: true
},
mappingKey: "test event"
}`}
  fn={logEvent}
/>

## Value mapping with getMappingValue

`getMappingValue(value: unknown, mapping: Mapping.Data, options?: Mapping.Options): Promise<WalkerOS.Property | undefined>`

This function transforms values using various mapping strategies.

### String key mapping

Use a string to extract a value by its property path:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
{ user: { id: '12345', name: 'John' } },
'user.id'
);`}
  output={`"12345"`}
  fn={logValue}
/>

### Array access

Access array elements using dot notation:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
{ products: ['laptop', 'mouse', 'keyboard'] },
'products.0'
);`}
  output={`"laptop"`}
  fn={logValue}
/>

### Static values

Return static values using the `value` property:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
{ name: 'page view' },
{ value: 'pageview' }
);`}
  output={`"pageview"`}
  fn={logValue}
/>

### Custom functions

Transform values using custom functions:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
{ user: { email: 'john@example.com' } },
{
fn: (event) => event.user.email.split('@')[1]
}
);`}
  output={`"example.com"`}
  fn={logValue}
/>

### Object mapping

Create new objects by mapping properties:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
{
product: { id: 'P123', name: 'Laptop', price: 999 },
user: { id: 'U456' }
},
{
map: {
  item_id: 'product.id',
  item_name: 'product.name',
  value: 'product.price',
  user_id: 'user.id',
  currency: { value: 'USD' },
}
}
);`}
  output={`{
item_id: "P123",
item_name: "Laptop",
value: 999,
user_id: "U456",
currency: "USD"
}`}
  fn={logValue}
/>

### Array processing with loop

Process arrays and transform each item:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
{
products: [
  { id: 'P1', name: 'Laptop' },
  { id: 'P2', name: 'Mouse' }
]
},
{
loop: [
  'products',
  { map: { item_id: 'id', item_name: 'name' } }
]
}
);`}
  output={`[
{ item_id: "P1", item_name: "Laptop" },
{ item_id: "P2", item_name: "Mouse" }
]`}
  fn={logValue}
/>

### Validation

Validate values and return undefined if validation fails:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
{ email: 'john@example.com' },
{
key: 'email',
validate: (value) => typeof value === 'string' && value.includes('@')
}
);`}
  output={`"john@example.com"`}
  fn={logValue}
/>

### Consent-based mapping

Only return values when required consent is granted:

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`await getMappingValue(
{
email: 'john@example.com',
consent: { marketing: false, functional: true }
},
{
key: 'email',
consent: { marketing: true }
}
);`}
  output={`undefined`}
  fn={logValue}
/>

## Policy

Policies modify events before processing. Apply them at **config-level** (all
events) or **event-level** (specific entity-action combinations).

**Processing order**: Config policy → Event matching → Event policy → Data
transformation

### Config-level policy

Global transformations applied to all events:

<CodeSnippet
  code={`config: {
policy: {
'user.email': { fn: (e) => e.user?.email?.toLowerCase() },
'data.timestamp': { fn: () => Date.now() },
},
}`}
  language="typescript"
/>

### Event-level policy

Transformations for specific events:

<CodeSnippet
  code={`config: {
mapping: {
product: {
view: {
  name: 'view_item',
  policy: {
    'data.id': { fn: (e) => \`PRODUCT_\${e.data?.id}\` },
  },
},
},
},
}`}
  language="typescript"
/>

Policies work with wildcards and conditions, and both levels can be combined -
config policy runs first, then event policy for the matched rule.

## Usage examples

### Source mapping

Normalize events before they reach the collector:

<CodeSnippet
  code={`await startFlow({
sources: {
browser: {
code: sourceBrowser,
config: {
  mapping: {
    // Rename DOM clicks to views
    product: {
      click: {
        name: 'product view',
        policy: {
          // Event-level: normalize product IDs
          'data.id': { fn: (e) => e.data?.id?.toUpperCase() },
        },
      },
    },
    // Ignore test events
    test: { '*': { ignore: true } },
  },
  policy: {
    // Config-level: normalize user email for all events
    'user.email': { fn: (e) => e.user?.email?.toLowerCase() },
  },
},
},
},
});`}
  language="typescript"
/>

### Destination mapping

Transform for specific destination APIs:

<CodeSnippet
  code={`await startFlow({
destinations: {
gtag: {
code: destinationGtag,
config: {
  mapping: {
    product: {
      view: {
        name: 'view_item',
        data: {
          map: {
            item_id: 'data.id',
            value: 'data.price',
            currency: { value: 'USD' },
          },
        },
      },
    },
  },
},
},
},
});`}
  language="typescript"
/>

### Combined flow

Event processed twice with different configs:

<CodeSnippet
  code={`// 1. Browser sends: "product click"
// 2. Source mapping: "product click" → "product view"
// 3. Destination mapping: "product view" → "view_item"
// 4. GA4 receives: "view_item"`}
  language="typescript"
/>

## Best practices

1. **Source mapping**: Normalize, filter, validate incoming events
2. **Destination mapping**: Transform to destination-specific formats
3. **Use specific mappings** over wildcards for better performance
4. **Validate critical data** before sending to destinations
5. **Respect consent** by using consent-based mappings
6. **Keep transformations simple** - complex logic in custom functions
