---
title: Create Your Own Source
description: Guide to building custom sources for walkerOS
sidebar_position: 99
---

# Create Your Own Source

A source captures events from an environment (browser, server, third-party API) and forwards them to the walkerOS collector.

## The source interface

Sources are async functions that receive a context object and return a source instance:

<CodeSnippet
  code={`type Source.Init<Types> = (
  context: Source.Context<Types>,
) => Source.Instance<Types> | Promise<Source.Instance<Types>>;`}
  language="typescript"
/>

The context contains:

<CodeSnippet
  code={`interface Source.Context<Types> {
  config: Partial<Source.Config<Types>>;  // Settings, mapping, options
  env: Types['env'];                       // Environment (push, logger)
  logger: Logger;                          // Logging functions
  id: string;                              // Source identifier
  collector: Collector.Instance;           // Collector reference
}`}
  language="typescript"
/>

The returned instance must implement:

<CodeSnippet
  code={`interface Source.Instance {
type: string; // Unique identifier
config: Source.Config; // Merged configuration
push: Elb.Fn; // Function to send events (forwards to env.elb)
destroy?(): void | Promise<void>; // Optional cleanup
on?(event, context): void | Promise<void>; // Optional reactive hooks
}`}
  language="typescript"
/>

## Types bundle

Sources use a `Types` interface to bundle all TypeScript types:

<CodeSnippet
  code={`import type { Source, Elb } from '@walkeros/core';

// 1. Define your settings
interface Settings {
captureClicks?: boolean;
prefix?: string;
}

// 2. Define environment dependencies
interface Env extends Source.BaseEnv {
customAPI?: YourAPIType;
}

// 3. Bundle them together
interface Types extends Source.Types<Settings, never, Elb.Fn, Env> {}`}
  language="typescript"
/>

**The 4 type parameters**:

1. **Settings**: Source configuration options
2. **Mapping**: Event mapping (usually `never` for sources)
3. **Push**: External push signature (what `source.push` exposes)
4. **Env**: Internal dependencies (what source calls via `env.elb`)

## Context destructuring

The `context` parameter contains everything your source needs:

<CodeSnippet
  code={`export const mySource: Source.Init<Types> = async (context) => {
  // Destructure what you need from context
  const { config = {}, env, logger, id } = context;
  const { push: envPush, customAPI } = env;

  // customAPI validation only needed if required by your source
  if (!customAPI) {
    throw new Error('Source requires customAPI in environment');
  }

  // Use env.push to send events to collector
  await envPush({ name: 'my event', data: { value: 'example' } });
};`}
  language="typescript"
/>

The collector provides `env.push` (formerly `env.elb`). You provide other dependencies (like `window`, `document`, custom APIs) when configuring the source.

## Minimal example

<CodeSnippet
  code={`import type { Source, Elb } from '@walkeros/core';

interface Settings {
  prefix?: string;
}

interface Env extends Source.BaseEnv {}

interface Types extends Source.Types<Settings, never, Elb.Fn, Env> {}

export const sourceCustom: Source.Init<Types> = async (context) => {
  const { config = {}, env } = context;
  const { push: envPush } = env;

  const settings: Source.Settings<Types> = {
    prefix: 'custom',
    ...config?.settings,
  };

  const fullConfig: Source.Config<Types> = {
    ...config,
    settings,
  };

  return {
    type: 'custom',
    config: fullConfig,
    push: envPush,
  };
};`}
  language="typescript"
/>

## Complete example: Event API source

Capturing events from a third-party API with event listeners:

<CodeSnippet
  code={`import type { Source, Elb } from '@walkeros/core';

// Your external API interface
interface ExternalAPI {
  on(event: string, handler: (data: unknown) => void): void;
  off(event: string, handler: (data: unknown) => void): void;
}

interface Settings {
  captureInteractions?: boolean;
  captureErrors?: boolean;
  prefix?: string;
}

interface Env extends Source.BaseEnv {
  api?: ExternalAPI;
}

interface Types extends Source.Types<Settings, never, Elb.Fn, Env> {}

export const sourceEventAPI: Source.Init<Types> = async (context) => {
  const { config = {}, env } = context;
  const { push: envPush, api } = env;

  if (!api) throw new Error('Source requires api instance');

  const settings: Source.Settings<Types> = {
    captureInteractions: true,
    captureErrors: true,
    prefix: 'app',
    ...config?.settings,
  };

  const handlers = new Map<string, (data: unknown) => void>();

  // Register event handler
  const register = (
    event: string,
    transform: (data: unknown) => { name: string; data: unknown },
  ) => {
    const handler = (data: unknown) => {
      const transformed = transform(data);
      envPush(transformed);
    };
    api.on(event, handler);
    handlers.set(event, handler);
  };

  // Set up event listeners based on settings
  if (settings.captureInteractions) {
    register('userAction', (data) => ({
      name: \`\${settings.prefix} interaction\`,
      data,
    }));
  }

  if (settings.captureErrors) {
    register('error', (data) => ({
      name: \`\${settings.prefix} error\`,
      data,
    }));
  }

  return {
    type: 'event-api',
    config: { ...config, settings },
    push: envPush,
    destroy: async () => {
      handlers.forEach((handler, event) => api.off(event, handler));
    },
  };
};`}
  language="typescript"
/>

## Using your source

<CodeSnippet
  code={`import { startFlow } from '@walkeros/collector';
import { sourceEventAPI } from './sourceEventAPI';

const externalAPI = getYourAPI();

const { elb } = await startFlow({
sources: {
eventAPI: {
code: sourceEventAPI,
config: {
  settings: {
    captureInteractions: true,
    prefix: 'myapp',
  },
},
env: {
  api: externalAPI, // Collector provides elb automatically
},
},
},
});`}
  language="typescript"
/>

## Testing your source

### Test Utilities

<CodeSnippet
  code={`// __tests__/test-utils.ts

export function createMockPush() {
  const mock = jest.fn();
  mock.mockResolvedValue({
    event: { id: 'test-id' },
    ok: true,
  });
  return mock;
}

export function createMockAPI() {
  return {
    on: jest.fn(),
    off: jest.fn(),
  };
}`}
  language="typescript"
/>

### Test Example

<CodeSnippet
  code={`import { sourceEventAPI } from '../index';
import type { Source, Collector } from '@walkeros/core';
import { createMockLogger } from '@walkeros/core';
import { createMockPush, createMockAPI } from './test-utils';

// Helper to create source context for testing
function createSourceContext(
  config: Partial<Source.Config<Types>> = {},
  env: Partial<Types['env']> = {},
): Source.Context<Types> {
  return {
    config,
    env: env as Types['env'],
    logger: env.logger || createMockLogger(),
    id: 'test-event-api',
    collector: {} as Collector.Instance,
  };
}

describe('Event API Source', () => {
  it('validates required dependencies', async () => {
    const push = createMockPush();

    await expect(
      sourceEventAPI(createSourceContext({}, { push }))
    ).rejects.toThrow('requires api');
  });

  it('registers event listeners', async () => {
    const api = createMockAPI();
    const push = createMockPush();

    await sourceEventAPI(
      createSourceContext(
        { settings: { captureInteractions: true } },
        { push, api }
      )
    );

    expect(api.on).toHaveBeenCalledWith('userAction', expect.any(Function));
  });

  it('transforms and forwards events', async () => {
    const api = createMockAPI();
    const push = createMockPush();

    await sourceEventAPI(createSourceContext({}, { push, api }));

    // Simulate event
    const handler = api.on.mock.calls[0][1];
    handler({ action: 'click' });

    expect(push).toHaveBeenCalledWith({
      name: 'app interaction',
      data: { action: 'click' },
    });
  });

  it('cleans up on destroy', async () => {
    const api = createMockAPI();
    const push = createMockPush();

    const source = await sourceEventAPI(createSourceContext({}, { push, api }));
    await source.destroy?.();

    expect(api.off).toHaveBeenCalled();
  });
});`}
  language="typescript"
/>

## Conditional activation with `require`

Sources can declare dependencies on collector events. A source with `require` won't initialize until all specified events have fired:

<CodeSnippet
  code={`await startFlow({
  sources: {
    session: {
      code: sessionSource,
      config: { require: ['consent'] },
    },
    dataLayer: {
      code: dataLayerSource,
      config: { require: ['user'] },
    },
  },
});`}
  language="typescript"
/>

**How it works:**

- Sources with `require` are stored in `collector.pending` instead of initializing
- After each collector event (`consent`, `user`, `session`, `run`, etc.), pending sources are checked
- When all required events have fired, the source initializes
- Chains work naturally: `consent` activates session source, which fires `user`, which activates dataLayer

**Common patterns:**

| Require | Use case |
|---------|----------|
| `['consent']` | Wait for CMP consent before tracking |
| `['user']` | Wait for identity resolution |
| `['session']` | Wait for session detection |
| `['consent', 'run']` | Wait for both consent and collector run |

## Common patterns

### Polling for API Readiness

When the external API isn't immediately available:

<CodeSnippet
  code={`async function waitForAPI<T>(getter: () => T | null): Promise<T> {
return new Promise((resolve) => {
const check = () => {
const instance = getter();
if (instance) resolve(instance);
else setTimeout(check, 100);
};
check();
});
}

// Usage
const api = await waitForAPI(() => window.myAPI || null);`}
  language="typescript"
/>

## Source as adapter pattern

Sources bridge external systems and the collector:

```
External System  ←→  Source (Adapter)  ←→  Collector
```

**Two interfaces:**

1. **External (`source.push`)**: Platform-specific signature
   * Browser: `push(elem, data, options)` → Returns `Promise<PushResult>`
   * Server: `push(req, res)` → Returns `Promise<void>` (writes HTTP response)
   * Your choice: Match your environment's needs

2. **Internal (`env.elb`)**: Standard collector interface
   * Always `Elb.Fn` - same across all sources
   * Sources translate external inputs → standard events → `env.elb(event)`

**Example signatures:**

<CodeSnippet
  code={`// Browser source
export type Push = (elem?: Element, data?: Properties) => Promise<PushResult>;

// HTTP handler source
export type Push = (req: Request, res: Response) => Promise<void>;

// Standard event source
export type Push = Elb.Fn;`}
  language="typescript"
/>

The `Push` type parameter defines what your source exposes externally. Internally, all sources use `env.elb` to forward to the collector.

## Key concepts

* **Context pattern**: Sources receive a single context object with config, env, logger, id
* **Validate custom dependencies**: Only check optional env properties your source needs
* **Types bundle**: Use 4-parameter pattern for full type safety
* **Adapter pattern**: External push adapts to environment, internal env.push stays standard
* **Cleanup**: Implement `destroy()` to remove listeners
* **Stateless**: Let collector manage state

## Package convention

Every walkerOS package includes machine-readable metadata for tooling and discovery.

### `walkerOS` field in package.json

<CodeSnippet
  code={`{
  "walkerOS": {
    "type": "source",
    "platform": "web",
    "schema": "./dist/walkerOS.json"
  },
  "keywords": ["walkeros", "walkeros-source"]
}`}
  language="json"
/>

| Field | Required | Description |
|-------|----------|-------------|
| `type` | Yes | `destination`, `source`, or `transformer` |
| `platform` | No | `web` or `server` (omit for platform-agnostic) |
| `schema` | No | Path to walkerOS.json (default: `./dist/walkerOS.json`) |

### Build-time generation

Use `buildDev()` from the shared tsup config to auto-generate `walkerOS.json`:

<CodeSnippet
  code={`import { buildDev } from '@walkeros/config/tsup';`}
  language="typescript"
/>

This file contains your package's JSON Schemas and examples, enabling MCP tools and the CLI to validate configurations without installing your package.

## Publishing checklist

- [ ] `walkerOS` field in package.json
- [ ] Keywords include `walkeros` and `walkeros-source`
- [ ] `buildDev()` in tsup.config.ts
- [ ] `dist/walkerOS.json` generated on build
- [ ] `npm run test` passes
- [ ] `npm run lint` passes

## Next steps

* Review <Link to="/docs/sources/web/browser">Browser Source</Link> for DOM patterns
* Review <Link to="/docs/sources/web/dataLayer">DataLayer Source</Link> for interception patterns
* Learn about <Link to="/docs/destinations/create-your-own">creating destinations</Link>
