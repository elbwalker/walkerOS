---
title: Router
description: Dynamic chain branching based on ingest metadata
sidebar_position: 2
package: '@walkeros/transformer-router'
---

# Router

<PackageLink env="server" github="packages/transformers/router" npm="@walkeros/transformer-router" />

Routes events to different transformer chains based on ingest metadata. The router inspects `context.ingest` (set by the source) and branches to the first matching route.

## Setup

<Tabs groupId="mode">
  <TabItem value="integrated" label="Integrated" default>

Install the package:

<CodeSnippet
  code={`npm install @walkeros/transformer-router`}
  language="bash"
/>

Configure in your code:

<CodeSnippet
  code={`import { startFlow } from '@walkeros/collector';
import { transformerRouter } from '@walkeros/transformer-router';

await startFlow({
  transformers: {
    router: {
      code: transformerRouter,
      config: {
        settings: {
          routes: [
            {
              match: { key: 'path', operator: 'prefix', value: '/gtag' },
              next: 'gtag-parser',
            },
            { match: '*', next: 'default-parser' },
          ],
        },
      },
    },
  },
});`}
  language="typescript"
/>

  </TabItem>
  <TabItem value="bundled" label="Bundled">

Add to your `flow.json`:

<CodeSnippet
  code={`"transformers": {
  "router": {
    "package": "@walkeros/transformer-router",
    "config": {
      "settings": {
        "routes": [
          {
            "match": { "key": "path", "operator": "prefix", "value": "/gtag" },
            "next": "gtag-parser"
          },
          { "match": "*", "next": "default-parser" }
        ]
      }
    }
  }
}`}
  language="json"
/>

[See Bundled Mode setup →](/docs/getting-started/modes/bundled) | [CLI reference →](/docs/apps/cli)

  </TabItem>
</Tabs>

## How it works

1. A server source (express, fetch) sets `context.ingest` with request metadata (path, method, headers, etc.)
2. The router evaluates routes **in order** — first match wins
3. On match, the event resets to `{}` and **branches** to the matched transformer chain
4. The downstream parser builds a proper event from `context.ingest`
5. If no route matches and there's no wildcard, the event passes through unchanged

## Route configuration

Each route has a `match` expression and a `next` target:

<CodeSnippet
  code={`interface Route {
  match: MatchExpression | '*';  // Condition or wildcard
  next: string | string[];      // Chain name(s) to branch to
}`}
  language="typescript"
/>

| Option | Type | Description |
|--------|------|-------------|
| `match` | `MatchExpression \| '*'` | Condition to evaluate against ingest, or `'*'` wildcard |
| `next` | `string \| string[]` | Transformer chain(s) to branch to on match |

## Match operators

| Operator | Description | Example |
|----------|-------------|---------|
| `eq` | Exact string match | `{ key: 'method', operator: 'eq', value: 'POST' }` |
| `prefix` | Starts with | `{ key: 'path', operator: 'prefix', value: '/api' }` |
| `suffix` | Ends with | `{ key: 'path', operator: 'suffix', value: '.json' }` |
| `contains` | Substring match | `{ key: 'path', operator: 'contains', value: 'collect' }` |
| `regex` | Regular expression | `{ key: 'path', operator: 'regex', value: '^/v\\d+/' }` |
| `gt` | Greater than (numeric) | `{ key: 'contentLength', operator: 'gt', value: '1000' }` |
| `lt` | Less than (numeric) | `{ key: 'contentLength', operator: 'lt', value: '5000' }` |
| `exists` | Key is present | `{ key: 'authorization', operator: 'exists', value: '' }` |

Every condition supports negation with `not: true`:

<CodeSnippet
  code={`{ key: 'method', operator: 'eq', value: 'GET', not: true }
// Matches any method except GET`}
  language="typescript"
/>

## Logical combinators

Combine conditions with `and` / `or`, nestable to any depth:

<CodeSnippet
  code={`// Match POST requests to /api/*
{
  and: [
    { key: 'path', operator: 'prefix', value: '/api' },
    { key: 'method', operator: 'eq', value: 'POST' },
  ]
}`}
  language="typescript"
/>

<CodeSnippet
  code={`// Match gtag OR Meta CAPI requests
{
  or: [
    { key: 'path', operator: 'prefix', value: '/gtag' },
    { key: 'path', operator: 'prefix', value: '/meta' },
  ]
}`}
  language="typescript"
/>

<details>
<summary>Deeply nested example</summary>

<CodeSnippet
  code={`// (path starts with /api AND method is POST)
// OR topic equals "shopify"
{
  or: [
    {
      and: [
        { key: 'path', operator: 'prefix', value: '/api' },
        { key: 'method', operator: 'eq', value: 'POST' },
      ],
    },
    { key: 'topic', operator: 'eq', value: 'shopify' },
  ]
}`}
  language="typescript"
/>

</details>

## Examples

### Multi-path server endpoint

Route different vendor payloads through dedicated parsers:

<CodeSnippet
  code={`{
  routes: [
    {
      match: { key: 'path', operator: 'prefix', value: '/gtag' },
      next: 'gtag-parser',
    },
    {
      match: { key: 'path', operator: 'prefix', value: '/meta' },
      next: 'meta-parser',
    },
    { match: '*', next: 'default-parser' },
  ]
}`}
  language="typescript"
/>

### Branching to multiple chains

A route can target multiple chains at once:

<CodeSnippet
  code={`{
  match: '*',
  next: ['validator', 'logger'],  // Fan out to both chains
}`}
  language="typescript"
/>

## Performance

Routes are compiled to closures at init time. Regular expressions are compiled once and reused on every request. Runtime evaluation is a simple loop with short-circuit logic for `and`/`or` combinators.

## Next steps

* **[Validator](./validator)** - Validate events after routing
* **[Create your own](./create-your-own)** - Build custom transformers
