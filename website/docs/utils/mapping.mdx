---
title: Mapping
sidebar_position: 5
---

import Link from '@docusaurus/Link';
import { LiveCode } from '@site/src/components/organisms/liveCode';
import { getMappingValue } from '@elbwalker/utils';
import { parseInput } from '@site/src/components/molecules/codeBox';
export const logFn = (input, config, log) => {
  log(parseInput(input, { getMappingValue }));
};

The `Mapping.Config` stores all
individual&nbsp;<Link to="/docs/destinations/event_mapping#eventconfig">`Mapping.EventConfig`</Link>
configurations for
each&nbsp;<Link to="/docs/getting_started/event-model">entity-action
event</Link>. The&nbsp;<Link to="#getmappingevent">`getMappingEvent`</Link>
function returns the matching event mapping while
the&nbsp;<Link to="#getmappingvalue">`getMappingValue`</Link> is used to resolve
a `Mapping.Value` settings for a specific property to return an actual value.
The `custom` property is used by
each&nbsp;<Link to="/docs/destinations/">destination</Link> individually.

```ts
// @TODO update me
const mapping: Config = {
  entity: {
    action: { name: 'entity_action' }, // Explicit EventConfig
    '*': {}, // Generic EventConfig for all entity entities
  },
  order: {
    complete: [
      {
        // EventConfig only for production
        condition: (event: WalkerOS.PartialEvent) =>
          event.globals?.env === 'prod',
        ignore: true,
      },
      { name: 'purchase' }, // Fallback EventConfig
    ],
  },
  '*': { '*': { ignore: true } },
};
```

## getMappingEvent

`getMappingEvent(event: string, mapping?: Mapping.Config<unknown>): EventMapping`
returns the matching `eventMapping` configuration and the used `mappingKey` for
the given entity-action event name. If no mapping is found, it will return an
empty object. An explicit key is favored over an asterisk `*` key. If available
a `condition` will be checked to determine if the `EventConfig` applies. It's
used by the&nbsp;<Link to="/docs/sources/">sources</Link>.

```ts
// @TODO remove the types?
interface EventMapping {
  eventMapping?: Event;
  mappingKey?: string;
}

getMappingEvent({ event: 'entity action' }, mapping);
// { eventMapping: { name: 'entity_action' }, mappingKey: 'entity action' }

getMappingEvent({ event: 'entity action' }, mapping);
// { eventMapping: { }, mappingKey: 'entity action' }

getMappingEvent({ event: 'order complete' }, mapping);
// { eventMapping: { name: 'purchase' }, mappingKey: 'order complete' }

getMappingEvent({ event: 'order complete', globals: { env: 'prod' } }, mapping);
// { eventMapping: { ignore: true, condition: Function }, mappingKey: 'order complete' }

getMappingEvent({ event: 'page view' }, mapping);
// { eventMapping: { ignore: true }, mappingKey: 'page view' }
```

## getMappingValue

`getMappingValue(event: WalkerOS.Event, mapping: Mapping.Value, options?: Mapping.Options): WalkerOS.Property | undefined`
primarily used by&nbsp;<Link to="/docs/destinations/">destinations</Link> to
process values from the original event. This offers flexibility to configure
individual&nbsp;<Link to="/docs/sources/walkerjs/tagging">tagging setups</Link>
to standard fields of the destination.

### string

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`getMappingValue(
    { a: 0, b: 1, c: 2 },
    'b',
  )`}
  output={`0`}
  fn={logFn}
/>

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`getMappingValue(
    { arr: ['foo', 'bar'] },
    'arr.1',
  );`}
  output={`"bar"`}
  fn={logFn}
/>

### key

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`getMappingValue(
    { foo: 'bar' },
    { key: 'foo' },
  );`}
  output={`"bar"`}
  fn={logFn}
/>

### value

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`getMappingValue({}, { value: 'foo' });`}
  output={`"foo"`}
  fn={logFn}
/>

### fn

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`getMappingValue(
    { foo: 'bar' },
    { fn: (obj) => obj.foo.toUpperCase() },
  );`}
  output={`"BAR"`}
  fn={logFn}
/>

### map

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`getMappingValue(
    { foo: 'bar' },
    {
      map: {
        foo: 'foo',
        bar: { value: 'baz' },
        obj: { map: { recursive: { value: true } } },
      },
    },
  );`}
  output={`{
    foo: 'bar',
    bar: 'baz',
    obj: { recursive: true },
  }`}
  fn={logFn}
/>

### loop

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`getMappingValue(
    { arr: [{ id: 'foo' }, { id: 'bar' }] },
    { loop: ['arr', 'id'] },
  );`}
  output={`['foo', 'bar']`}
  fn={logFn}
/>

### validate

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`getMappingValue({ foo: 'bar' }, { key: 'foo', validate: (v) => v === 'bar' });`}
  output={`"bar"`}
  fn={logFn}
/>

### consent

<LiveCode
  showMiddle={false}
  labelInput="Configuration"
  input={`getMappingValue(
    { name: 'foo', consent: { functional: true } }, // event with consent state
    { key: 'name', consent: { marketing: true } }, // required consent
    { instance }, // instance with consent state
  );`}
  output={`undefined (no marketing required consent)`}
  fn={logFn}
/>

First the `condition` is checked to determine if the `ValueConfig` should be
used. Second, the `consent` state gets checked if an `instance` is provided. If
no required consent is given, no value will be returned. If a `fn` is provided,
it will be called to define the value, otherwise the `key` or initial `string`
value will be used
with&nbsp;<Link to="/docs/utils/helper#getbypath">byPath</Link>. The current
value will be check using the `validate` function and set to `undefined` if it
fails. Finally, the `value` will be cast to match the `WalkerOS.Property` type.
An empty `ValueType` will return `undefined`.

:::info

If you need professional support with your walkerOS implementation, check out
our&nbsp;<Link to="/services">services</Link>.

:::
