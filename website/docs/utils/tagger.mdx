---
title: Tagger
sidebar_position: 8
---

import PackageLink from '@site/src/components/docs/package-link';
import Link from '@docusaurus/Link';
import { LiveCode } from '@site/src/components/organisms/liveCode';
import { createTagger } from '@walkerOS/core';
import { parseInput } from '@site/src/components/molecules/codeBox';

export const runTagger = async (input, config, log) => {
  const tagger = createTagger();
  log(await parseInput(input, { createTagger, tagger }));
};

<PackageLink github="packages/core" npm="@walkerOS/core" />

The Tagger is a chainable utility for generating `data-elb` attributes for HTML
elements. It provides a clean, type-safe API to build structured tracking
attributes that integrate seamlessly with walkerOS's
[HTML tagging system](/docs/sources/html-tagging).

## Why Use the Tagger?

The tagger solves common problems when manually creating `data-elb` attributes:

- **Type Safety**: Ensures correct attribute structure and value types
- **Value Escaping**: Automatically handles special characters (`;`, `:`, `'`,
  `\`)
- **Chainable API**: Fluent interface for building complex attribute sets
- **Consistent Naming**: Follows walkerOS attribute naming conventions
- **State Accumulation**: Multiple calls add to existing properties

## Installation

```bash
npm install @walkerOS/core
```

## Basic Usage

First, create a tagger instance:

```javascript
const tagger = createTagger();
```

Then use it to build attributes:

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger('product')
  .data('id', 123)
  .data('name', 'Widget')
  .get();`}
  output={`{
  "data-elb": "product",
  "data-elb-product": "id:123;name:Widget"
}`}
  fn={runTagger}
/>

## Usage

### Factory Function

The `createTagger()` function creates a new tagger factory with optional
configuration.

```javascript
// With custom prefix
const customTagger = createTagger({ prefix: 'data-track' });
customTagger('product').data('id', 123).get();
// Returns: { "data-track": "product", "data-track-product": "id:123" }
```

Examples below use the default tagger created with `createTagger()`.

### Entity Method

Sets the entity scope for data properties.

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger().entity('product').get();`}
  output={`{
  "data-elb": "product"
}`}
  fn={runTagger}
/>

### Data Method

Adds data properties. Supports both single key-value and object parameters.

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger('product')
  .data({ id: 123, name: 'Widget', price: 99.99 })
  .get();`}
  output={`{
  "data-elb": "product",
  "data-elb-product": "id:123;name:Widget;price:99.99"
}`}
  fn={runTagger}
/>

### Action Method

Adds action definitions for event triggers. Supports multiple formats.

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger()
  .action({ load: 'view', click: 'select' })
  .get();`}
  output={`{
  "data-elbaction": "load:view;click:select"
}`}
  fn={runTagger}
/>

### Context Method

Adds contextual information.

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger()
  .context({ test: 'engagement', position: 'header' })
  .get();`}
  output={`{
  "data-elbcontext": "test:engagement;position:header"
}`}
  fn={runTagger}
/>

### Globals Method

Adds global properties.

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger().globals('lang', 'en').get();`}
  output={`{
  "data-elbglobals": "lang:en"
}`}
  fn={runTagger}
/>

### Link Method

Adds link definitions for connected elements.

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger().link('details', 'parent').get();`}
  output={`{
  "data-elblink": "details:parent"
}`}
  fn={runTagger}
/>

## Advanced Examples

### State Accumulation

Multiple calls to the same method accumulate values:

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger('product')
  .data('id', 123)
  .data('name', 'Widget')
  .data({ price: 99.99, category: 'electronics' })
  .action('load', 'view')
  .action('visible', 'impression')
  .get();`}
  output={`{
  "data-elb": "product",
  "data-elb-product": "id:123;name:Widget;price:99.99;category:electronics",
  "data-elbaction": "load:view;visible:impression"
}`}
  fn={runTagger}
/>

### Multiple Entities

Change entity scope within the same chain:

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger('product')
  .data('id', 123)
  .entity('user')
  .data('name', 'John')
  .action('load', 'view')
  .get();`}
  output={`{
  "data-elb": "user",
  "data-elb-product": "id:123",
  "data-elb-user": "name:John",
  "data-elbaction": "load:view"
}`}
  fn={runTagger}
/>

### Complete Example

A comprehensive example showing all features together:

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger('product')
  .data('id', 123)
  .data({ name: 'Widget', price: 99.99 })
  .action('load', 'view')
  .action({ click: 'select' })
  .context('test', 'engagement')
  .globals('lang', 'en')
  .link('details', 'parent')
  .get();`}
  output={`{
  "data-elb": "product",
  "data-elb-product": "id:123;name:Widget;price:99.99",
  "data-elbaction": "load:view;click:select",
  "data-elbcontext": "test:engagement",
  "data-elbglobals": "lang:en",
  "data-elblink": "details:parent"
}`}
  fn={runTagger}
/>

## Value Escaping

The tagger automatically escapes special characters that could break attribute
parsing:

<LiveCode
  showMiddle={false}
  labelInput="Code"
  input={`tagger()
  .context('test', "a;b:c'd\\\\e")
  .get();`}
  output={`{
  "data-elbcontext": "test:a\\\\;b\\\\:c\\\\'d\\\\\\\\e"
}`}
  fn={runTagger}
/>

**Escaped characters:**

- `;` → `\\;` (property separator)
- `:` → `\\:` (key-value separator)
- `'` → `\\'` (quote character)
- `\\` → `\\\\` (escape character itself)

## React Integration

Perfect for React components with the spread operator:

```jsx
import { createTagger } from '@walkerOS/core';

const tagger = createTagger();

function ProductCard({ product }) {
  return (
    <div
      {...tagger('product')
        .data({ id: product.id, name: product.name, price: product.price })
        .action('load', 'view')
        .context('test', 'engagement')
        .get()}
      className="product-card"
    >
      <h2>{product.name}</h2>
      <p>${product.price}</p>
      <button {...tagger().action('click', 'purchase').get()}>Buy Now</button>
    </div>
  );
}
```

## Integration with walkerOS

The generated attributes work seamlessly with walkerOS's HTML source:

```jsx
// This component automatically tracks when loaded and clicked
function TrackedButton({ productId, action }) {
  return (
    <button
      {...tagger('product')
        .data('id', productId)
        .action({ load: 'view', click: action })
        .context('component', 'tracked-button')
        .get()}
      onClick={() => console.log('Button clicked')}
    >
      {action}
    </button>
  );
}
```

When this element appears in the DOM, walkerOS will automatically:

1. Fire a `product view` event when the element loads
2. Fire a `product [action]` event when clicked
3. Include the product ID and component context in both events

## TypeScript Support

Full TypeScript support with proper types from `@walkerOS/types`:

```typescript
import {
  createTagger,
  type TaggerConfig,
  type TaggerInstance,
} from '@walkerOS/core';

const config: TaggerConfig = { prefix: 'data-track' };
const tagger = createTagger(config);

const instance: TaggerInstance = tagger('product');
const attributes: Record<string, string> = instance.data('id', 123).get();
```
